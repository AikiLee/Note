这个主要是注意开闭区间

## 左闭右开

右边时虚位

```py
def binary_search(nums:List[int],target:int) -> int:
	n = len(nums)
	left,right = 0,n
	while left < right :
		mid = left + ((right - left) //2)
		if nums[mid] < target:
			# target is in behind
			left = mid + 1
		elif nums[mid] > target:
			# target is in front
			right =  mid 
		else: 
			return mid
	return -1

```

现在推荐使用开区间做法
```py
def binary_search(nums:List[int],target: int) ->:
	n = len(nums)
	left, right = -1, n
	while left + 1< right:
		mid = left + (right - left) // 2
		if nums[mid] < target:
			left = mid
		elif nums[mid]>target:
			right = mid
		else:
			return mid
	return -1
```

相关题目

| 题目                                                                                                                 | 介绍                                       | 提示  |
| ------------------------------------------------------------------------------------------------------------------ | ---------------------------------------- | --- |
| [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)                                                 | 二分法的简单应用，这一题的核心就是理解这个位置就是>=target的第一个位置  |     |
| [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) | 对上一题的升级，需要将插入位置算法修改一下，因为有重复想，两个区间一减就是结果了 |     |
| [69. x 的平方根](https://leetcode.cn/problems/sqrtx/)                                                                  | 注意大整数的处理方法，先定义再引用。基本操作还是和二分法一致           |     |
|                                                                                                                    |                                          |     |
