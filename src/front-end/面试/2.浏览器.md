## 1.url解析过程

这里我仅给出比较简单的过程。

1. user输入url
2. 先做域名解析。浏览器先向本地缓存查询domain，如果找不到
3. browser会向本地ISP查询domain，如果没找到会递归地向上级dns服务器查询
4. 找到域名之后，返回ip地址
5. 建立和对应主机之间的连接，一般是http(s)
6. 服务器返回html信息，浏览器接受并渲染页面

## 2.浏览器加载原理

这里需要借助一张图来理解：

1. 浏览器接受来自服务器的html信息后，会将HTML和css样式并行解析形成`DOM tree`和`CSSOM tree`
2. 执行js代码，这里可能会修改DOM/CSSOM
3. 形成render tree，将 DOM 树和 CSSOM 树结合，形成渲染树（包含可视化元素及其样式信息）
4. 计算layout，计算每个元素在视口中的确切位置和大小
5. painting， 将每个元素转换为屏幕上的实际像素

## 3.重绘和重排

[掘金-重绘重排](https://juejin.cn/post/6957983730531041287)

当页面元素变化时，可能会引起dom元素变换，浏览器会重新渲染页面，这将耗费大量时间。从下面的代码可以看出经常性的修改网页元素，会极大增加页面渲染时间:

重拍的时间显著超过重绘，大概高两个数量级

```js
var times = 15000
// 利用js单线程执行的特性
// code1 每次过桥+重排+重绘
console.time(1)
for (var i = 0; i < times; i++) {
    document.getElementById('myDiv1').innerHTML += 'a'
}
console.timeEnd(1)

// code2 只过桥
console.time(2)
var str = ''
for (var i = 0; i < times; i++) {
    var tmp = document.getElementById('myDiv2').innerHTML
    str += 'a'
}
document.getElementById('myDiv2').innerHTML = str
console.timeEnd(2)

// code3
console.time(3)
var _str = ''
for (var i = 0; i < times; i++) {
    _str += 'a'
}
document.getElementById('myDiv3').innerHTML = _str
console.timeEnd(3)

// code4 仅触发重绘
console.time(4);
var element = document.getElementById("myDiv4");
element.innerHTML = "初始文本";
for (var i = 0; i < times; i++) {
	element.style.color = i % 2 ? "red" : "blue";
}
console.timeEnd(4);
// ans
1: 244.610107421875 ms
2: 1.3310546875 ms
3: 0.343994140625 ms
4: 1.925048828125 ms
```

## 4.如何触发重排何重绘

每次重排都会触发重绘：

1. 添加或者删除可见的DOM元素
2. 元素位置改变, position
3. 元素尺寸的改变
4. 页面渲染初始化（这个无法避免）
5. 浏览器窗口尺寸改变, resize
6. 元素style的修改

仅触发重绘：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，常见重绘属性：
color，border，outline，background

## 5.如何避免重绘或者重排，或者说减少影响？

### (1)减少重排范围

- 尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围（BFC）
- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。

### (2)减少重排次数

1. 对于页面来说，明智且可维护的做法是更改类名而不是修改样式
2. 利用style.cssText或者classname进行批量修改

### (3)分离读写操作

```js
// bad 强制刷新 触发四次重排+重绘
div.style.left = div.offsetLeft + 1 + 'px'
div.style.top = div.offsetTop + 1 + 'px'
div.style.right = div.offsetRight + 1 + 'px'
div.style.bottom = div.offsetBottom + 1 + 'px'
// good 缓存布局信息 相当于读写分离 触发一次重排+重绘
var curLeft = div.offsetLeft
var curTop = div.offsetTop
var curRight = div.offsetRight
var curBottom = div.offsetBottom
div.style.left = curLeft + 1 + 'px'
div.style.top = curTop + 1 + 'px'
div.style.right = curRight + 1 + 'px'
div.style.bottom = curBottom + 1 + 'px'
```

###### 为什么读写分离后只触发一次重排

- 这都得益于浏览器的渲染队列机制
- 当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。

## 6.vue中的重绘和重排

其实vue/react使用的虚拟dom已经最小化dom操作，并且其中对dom操作的优化已经十分多。例如vue会将操作缓存，集中修改。同时使用diff算法减小影响范围。其中优化的操作：

1. v-if/show：减少不必要的渲染，v-show适合通过CSS控制元素的显示和隐藏，不会销毁元素。适用于需要频繁显示和隐藏的场景
2. 集中更新，和使用`nextTick`避免重复渲染
3. 使用key来提升diff算法效率
4. 合理使用computed/watch，减少不必要渲染

## 7.浏览器的缓存机制 强制缓存 && 协商缓存

![p1](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/487144abaada4b9a8b34bc9375191ec7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

我们看上图就能发现：
1. 每次发送请求都会检查浏览器缓存和缓存标识
2. 如果找不到才会发继续发起请求
以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是`强制缓存`和`协商缓存`。

[知乎-浏览器缓存机制](https://zhuanlan.zhihu.com/p/99340110)
[思否](https://segmentfault.com/a/1190000017962411)

当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`，其中 Cache-Control 优先级比 Expires 高。
### 强制缓存

强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）;
2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存;
3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

### 协商缓存

`协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程`，同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。协商缓存主要有以下两种情况：

1. 协商缓存生效，返回 304;
2. 协商缓存失效，返回 200 和请求结果结果。

## 8. localStorage/sessionStorage/cookie区别
这里从四个方面来考虑：生命周期，存储大小，与服务器的通信和API易用性
1. 生命周期：
	- cookie可以单独设置时间来控制
	- localStorage没有时间限制
	- sessionStorage则只在单次会话中，浏览器关闭就消失
2. 存储大小
	- cookie一般为4kB
	- sessionStorage/localStorage一般为5-10MB
3. 与服务器通信：
	- cookie一般用于存储用户的认证信息，**每一次** HTTP 请求中被自动携带在请求头中发送给服务器
	- localStorage一般存一些不太会变动的东西，例如用户设置
	- sessionStorage因为生命周期的限制，一般存储一些临时数据
4. 易用性
	- cookie使用较为复杂：通过document.cookie获取，然后手动解析
	- 后二者责较为方便，直接`getItem/setItem/clear/removeItem
5. 安全性
	- cookie可以设置`HttpOnly(放置js访问)`和`Secure(仅在https下传输)`
	- 后两者则只受浏览器的同源限制，但是又可以通过js访问所以很容易受到xss攻击

## 9.语意化HTML

就是使用正确的标签来描述内容，hmlt5中浏览器对很多内容原生就有很好的支持，例如`<header> <nav> <main> <article>`使用这些标签可以帮助浏览器更好地理解页面，提升无障碍，seo效果