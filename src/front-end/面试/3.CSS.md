## 1.css选择器和优先级

主要有如下这些选择器：

1. ID
2. 类
3. 标签
4. 伪类`a:active/p:nth-child()`：对伪类进行处理
5. 属性`input[type='text']/a[href='#']`: 选中特定属性

6. 相邻兄弟`h1 ~ p`：选择当前元素之后的所有兄弟节点
7. 子 `ul li`：仅能选择下一层级，不能更下了
8. 后代 `li a` ：只有层级有父子关系的才选
9. 通配符`*`: 选所有

### 优先级

- !important > 行内样式 > ID 选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性
  重点就是记住数值了：

1. 内联：1000
2. ID：0100
3. 类选择器/属性选择器/伪类选择器：0010
4. 元素/伪类：0001
5. 关系/通配符：0000

## 2.position

主要有5中属性：

```css
position: static; #默认值，元素处于文档流中，忽略top/bottom...z-index
position: fixed; # 固定位置，元素脱离文档流
positoin: relative/absolute; # 一般配合使用，absolute脱离文档流,并靠近最近的文档流元素，relative基于absolute进行偏移
position: sticky; # 元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。例如先sticky再top：10%,即当页面高度滑动到窗口10px的位置时，变为fixed

```

## 3.box-sizing

改变浏览器计算长宽的方式:
例如：

```css
box-sizing: content-box; # default
width:100px; #这就是表示元素内容宽度为100px，元素的宽度还要加上padding,border

box-sizing: border-box; # 表示width = content + padding*2 + border*2

```

## 4.盒模型

[思否-bfc](https://segmentfault.com/a/1190000009545742#item-6-3)

在 CSS 中，所有的元素都被一个个的“盒子”包围着。元素被基本分成：inline, inline-box, box。行内元素有很多不好的特性

## 5.BFC

BFC 是 Block Formatting Context 的缩写，即块级格式化上下文。BFC 是 CSS 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局， 并且这个区域的子元素不会影响到外面的元素，有如下特点:

- bfc内部的元素不会与外部元素互相影响
- 内部的box元素会在垂直方向上一个一个放置
- 垂直方向的距离由margin决定
- 每个元素的左外边缘（`margin-left`)， 与包含块的左边（`contain box left`）相接触(对于从左往右的格式化，否则相反)，其实就是左对齐
- BFC的区域不会与`float box`重叠。
- BFC计算高度时，float元素也会参与计算

这些特性可以帮助我们解决如下开发中常遇到的问题：

1. 高度塌陷：在一个父元素下，子元素如果有float，那么父级元素的高度就会塌陷掉。这时候我们就可以让父级元素生成bfc来处理；当然可以使用伪类来清除浮动

````html
<div class="wrap">
    <section>1</section>
    <section>2</section>
</div>
.wrap { border: 2px solid yellow; width: 250px; } section { background-color:
pink; float: left; width: 100px; height: 100px; } ``` 2.
外边距折叠：两个相邻的盒元素，其外边距会产生折叠，例如两个margin:
50px的盒子，间距却只有50px， ```html
<section class="top">1</section>
<section class="bottom">2</section>
section { background-color: pink; margin-bottom: 100px; width: 100px; height:
100px; } .bottom { margin-top: 100px; }
````

3. 避免某元素被浮动元素覆盖：例如使用float实现一个两栏自适应布局

触发BFC方式

1. float不为none
2. display:inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid
3. position: absolute/fixed
4. overflow: 不为visible

## 6.让一个元素水平居中

这个首先需要有一个分类的意识：

1. 元素是block还是非block
2. 是水平还是垂直
3. 元素有无width

### 块级元素居中

对于块级元素：
可以使用：

```css
margin: 0 auto; #适合有固定width/height
# 绝对定位
transform
gird/flex
```

### 非块级元素

对于非块级元素： `text-align: center; line-height: center`

### 有无固定宽度

1. 对于有固定宽度:
    - 可以使用margin: 0 auto;
    - 绝对定位配合margin-left/top/left...
2. 没有固定宽度：
    - 绝对定位+transform
    - flex/grid,中使用justify-content/align-items

## 7.隐藏元素

三种方式：

1. `display: none`: 将元素移除render tree，但是还在dom树中，元素不占位置；这将导致重排重绘
2. `visibility: hidden`：元素在render tree中，也占据位置，只是不展示；会导致重绘
3. `opacity: 0`：元素在render tree，占据位置，可以触发事件，只是透明度为0；

## 8.layout

### flex布局

弹性布局，为盒模型提供极大的灵活性：开启：`display: flex`

#### 1.容器属性

`flex-direction: column | row | column-reverse | row-reverse (default)`方向

`flex-wrap: nowrap| wrap| wrap-reverse`换行控制

`flex-flow: direction || wrap`: 上面二者组合

`justify-content: start | end | center| space-between | space-around`主轴方向上的布局

`align-items:flex-start | flex-end | center | baseline(项目的第一行文字的基线对齐) | stretch`交叉轴方向的布局

`align-content`:多根轴的布局方式

#### 2.项目属性

`flex-grow: <number>`: 容器宽度>元素总宽度时如何伸展, 默认为0，不放大

`flex-shrink: 1(default: auto shrink) `:容器宽度<元素总宽度时如何收缩

`flex-basis: <length/px/%> | auto` ：计算元素在主轴上的占据空间

`flex= grow shrink basis`

`order`:显示顺序，默认为0 ，越小排的越前

`align-item`:元素内部的单个项目的对齐

### grid布局

网格布局，基于网格线来布局：

#### core

在父级元素开启`display:grid`，如果项目比较固定，可以使用grid-template-row/column来指定行数，列数

```css

.wrapper {
  display: grid;
  /*  声明了三列，宽度分别为 200px 200px 200px */
  grid-template-columns: 200px 200px 200px;
  grid-gap: 5px;
  /*  声明了两行，行高分别为 50px 50px  */
  grid-template-rows: 50px 50px;
}
//简写
.wrapper {
  display: grid;
  grid-template-columns: repeat(3,200px);
  grid-gap: 5px;
  grid-template-rows:repeat(2,50px);
  //当然如果是一边固定，一边弹性， 也是否容易
  grid-template-rows: 250px 1fr 2fr; #其中fr是剩余空间的占比，1/3 2/3
  # 还可以结合css函数来实现更细致的操作
  grid-template-rows: 250px minmax(100px, 1fr) 2fr;
}
```

#### 在使用模版划分之后，还可以合并单元格

`grid-column-start、grid-column-end 、grid-row-start 、grid-row-end` 再结合网格线。但我更喜欢使用简化版本`grid-column: 1/span2`

#### grid-template-areas 属性

先使用template划分，再直接指定，由浏览器直接分配

```css
.container {
    display: grid;
    grid-template-columns: 100px 100px 100px;
    grid-template-rows: 100px 100px 100px;
    grid-template-areas:
        'a b c'
        'd e f'
        'g h i';
}
```

#### 也是弹性布局，和flex一样可以用：justify-content, align-items

### Flex vs Grid

1. **是什么 (What):**  
    Flexbox 和 Grid 都是现代 CSS 的核心布局模型。一言以蔽之，**Flexbox 是一维布局系统，而 Grid 是二维布局系统**。
    
2. **为什么 (Why):**  
    它们诞生的目的是为了解决不同的布局问题。**Flexbox 的设计初衷是处理沿单根轴线（行或列）的元素对齐、分布和排序**，它非常适合构建“内容驱动”的组件级布局。而 **Grid 则是为了解决宏观的、网格化的页面布局**，它可以同时控制行和列，实现过去需要复杂 hack 才能完成的对齐，是一种“布局驱动”的系统。
    
3. **怎么做 (How):**  
    在实践中，我会根据场景来选择：
    
    - **使用 Flexbox：** 当我需要制作一个导航栏、一个卡片内的元素排列，或者任何一组项目需要沿单条线分布时，Flexbox 是首选。例如，display: flex; justify-content: space-between; 可以轻松实现两端对齐。要实现侧边栏固定宽度、主内容区自适应的布局，flex: 0 0 200px; 和 flex: 1 1 auto; 是非常经典的用法。
        
    - **使用 Grid：** 当我需要搭建整个页面的骨架，比如圣杯布局或复杂的仪表盘界面时，Grid 无疑是更好的选择。通过 grid-template-areas 或 grid-template-columns: 200px 1fr; 可以非常直观地定义出二维结构。Grid 的 fr 单位和 gap 属性在处理响应式网格和间距时也比 Flexbox 更强大。
        
    - **最佳实践：** 两者并非互斥，而是可以完美结合。通常我会用 Grid 做页面的整体布局，而在 Grid 的单元格内部，使用 Flexbox 来对齐和排列具体内容。
        
4. **我的实践 (Experience):**  
    在我之前的一个项目中，我们需要构建一个复杂的仪表盘。初版方案尝试用多层嵌套的 Flexbox 来实现，结果导致 HTML 结构非常臃肿，出现了很多无意义的 `<div>` 包装层，CSS 也变得难以维护。后来我们进行了重构，**在顶层使用 CSS Grid 来定义仪表盘的几个主要区域（侧边栏、头部、主内容区）**。代码不仅变得极其简洁和声明式，而且在后续调整响应式断点时，我们只需要修改顶层的 grid-template-areas 即可，维护性得到了极大的提升。

## 9.清除浮动的方式

[思否-清除浮动](https://segmentfault.com/a/1190000004237437)

在使用float会出现问题：（1）：背景不能显示 （2）：边框不能撑开 （3）：margin 设置值不能正确显示

1. 添加类来清除

```css
clear {
    clear: both;
}
```

2. 父级div定义 overflow: auto, 感觉利用了BFC
3. 使用伪类`:after{ clear:both}`

## 10.响应式设计

响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整

响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有`meta`声明`viewport`

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”>
```

使用响应式布局常用方法：

- 媒体查询
- 百分比
- vw/vh
- rem
