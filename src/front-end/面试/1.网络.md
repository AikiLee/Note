对于八股文的回答，我们可以从五个层次上回答：
1. 是什么，最好使用专业术语来描述这个问题，使回答专业化
2. 为什么，需要较为深入理解这个问题，例如v-for为什么要加key，就要追踪到vue的diff算法，加key可以优化渲染效率，减少dom更新次数，减少出错的概率：因为vue使用虚拟dom，其和真实数据之间的映射是通过xxx维护的，如果不加key，vue就倾向于修改内容，而非移动dom元素
3. 怎么做，在具体的操作中可能会引出的问题，何时用何时不用：加什么key，是使用index还是一个新字段，正确的做法是加唯一标识，因为如果这个列表涉及修改删除排序之类的操作，那么就会引入index的变动导致渲染错误，以至于失去功能。因此对于纯静态展示的页面，加不加影响不大，其他情况都应该加
4. 结合自己的具体操作情况：例如，在自己的项目中，当时是一个动态的问卷表单，用户可以添加或删除问题。我们最初不规范地使用了 index 作为 key。当用户删除中间的一个问题时，下面所有问题的用户输入内容和校验状态都错位了。通过 Debug，我们发现是 Vue 复用了组件实例导致的。后来将 key 统一改成问题自身的唯一 questionId，问题就解决了。那次经历让我深刻理解到，key 的核心是**身份识别 (identity)**，而不仅仅是性能优化 (performance)
## 1.HTTP/HTTPS
`http`:是基于tcp的用于在客户端和服务器之间传输超文本的协议
`https`:由于http传输信息是明文的，数据在传输中容易被窃取和修改，所以在此基础上，对数据采用tls/ssl加密，保证传输的可靠，

## 2.HTTPS的工作原理

1. 客户端使用https协议访问，就会请求和web服务器建立`ssl`链接
2. server收到请求之后，就会将网站证书(包含公钥)传递给客户端
3. 客户端服务端协商ssl加密等级
4. 协商完成，建立会话密钥，一般是使用服务器的公钥来加密会话
5. 服务器通过自己的私钥来解密会话

## 3.TCP三次握手和四次挥手

### 三次握手

1：建立连接时，client会发送SYN=1(同步序列编号)，seq=j，发送之后会进入到SYN_SENT状态
2：server接收到请求后，会响应一个SYN = 1, ACK = 1， seq=k, ack = j+1的报文，发送之后进入到SYN_RVID
3：client在接受到响应之后，再次发送一个ACK=1, ack=k+1的报文，确认应答。此时server的状态是ESTABISHED

Q1：为什么要发第三次请求？
为了防止重复建立连接，浪费服务器资源。因为网络是不稳定有波动的，如果之前的连接建立请求报文，因为网络延时而到达，此刻如果只有两次，就会重复建立连接。

### 四次挥手

1：client请求断开连接，发送一个FIN=1，seq=j的报文，进入FIN_WAIT1
2：server响应报文ACK=1,ack=j+1，seq=k之后进入CLOSE_WAIT状态
3：client接受响应报文，进入FIN_WAIT2。之后server发送连接释放报文，FIN=1,ACK=1,seq=z,ack=j+1,之后进入LAST_ACK状态
4：client响应报文，ACK=1,ack=z+1,seq=j+1，进入TIME_WAIT状态；server接收到报文之后直接进入CLOSED状态；最后2MSL之后client才会进入closed状态

Q1: 为什么 TCP 关闭连接为什么要四次而不是三次？
服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段，接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。

Q2：客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？
网络并不总是可靠的，如果客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 报文段。因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间，如果在此期间又收到了来自服务器的 FIN 报文段，那么客户端会重新设置计时器并再次等待 2MSL 的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了


## 4.TCP/UDP

`TCP`:TCP 是**面向连接**的、**可靠**的流协议。常用于：http，ftp，smtp
`UDP`:无连接，不可靠具体的处理交给应用层处理，面向报文。长用于：dns，音视频，广播

## 5.GET/POST

Q: 请讲一讲二者区别
ANS：
1. 参数位置：get请求参数放在url中直接显示，post则是放在请求体中。
2. 对参数的长度支持不同，http协议对body中携带的参数没有长度限制，但是浏览器一般会对url长度有限制，而且不尽相同。例如`IE`:2083B
3. 浏览器处理发送的方式不同，对于大多数浏览器，处理get请求，会直接将`http-header`和`data`一起发送。而对于post则会先发送`header`,服务器响应100-continue，才会继续返回data。FireFox则不同，会直接发送。如果响应的不是100，需要等待并处理服务器的最终响应。

## 6.HTTPS是如何保证安全的

http面临的风险主要是：
1. **窃听风险**（eavesdropping）：第三方可以获知通信内容。  
2. **篡改风险**（tampering）：第三方可以修改通信内容。  
3. **冒充风险**（pretending）：第三方可以冒充他人身份参与通信。

因此，SSL/TLS 协议就是为了解决这三大风险而设计的，希望达到：
1. 所有信息都是**加密传播**，第三方无法窃听。
2. 具有**校验机制**，一旦被篡改，通信双方会立刻发现。
3. 配备**身份证书**，防止身份被冒充。
### （1）会话加密
https的基本思路就是客户端会向服务端所要公钥（一般ca证书中就包含），并采用这个公钥来加密会话。服务端收到信息之后，会用自己的私钥来解密。

### （2）保证公钥不被修改

将公钥放在[数字证书](https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Digital_certificate)中。只要证书是可信的，公钥就是可信的。这里的利用了ca证书进行检验

### （3）身份冒充

利用ca证书的信任链。



