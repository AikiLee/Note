## 数组转树(leetcode)

leetcode给的树是数组形式，我们需要通过操作将其转换为真实的二叉树。

```js
//   Definition for a binary tree node.
function TreeNode(val, left, right) {
    this.val = val === undefined ? 0 : val;
    this.left = left === undefined ? null : left;
    this.right = right === undefined ? null : right;
}

// 层序构建树
const makeTree = (arr) =>{
    if(arr.length === 0) return null;
    let root = new TreeNode(arr[0]);
    let cur = root;
    for(let i =  1 ; i< arr.length; i++){
        let node = new TreeNode(arr[i]);
        cur.left = null;
        cur.right = node;
        cur = node;
    }
   return root; 
}

```

## 前缀树

这也算一种特殊的数据结构，将字符串存到数组中，便于查找。使得操作的时间复杂度降低为`O(L)` 其中L = str.length

```js
// @lc code=start
class Node {
    /**
     * 构造函数，生成一个节点，包含26个字母的hash，和end
     */
    constructor() {
        this.son = new Array(26).fill(null);
        this.isEnd = false;
    }
}


class Trie { 
    /**
     * 前缀树的特点：
     * 1. root为null
     * 2. 每个节点包含两个属性，(1)存储一个字母的hash，使用cur.charCodeAt(0) - 'a'.charCodeAt(0)来存 (2)一个标志isEnd用于判断当前节点是否是一个单词的结束
     * 3. 每个节点的所有子节点都应该不同.
     */

    constructor() {
        this.root = new Node();
    }
    /**
     * 
     * @param {*} word 
     * 在前缀树中查找一个单词。和插入基本一致，注意返回值
     * @return 0:匹配失败 ; 1:前缀匹配 ; 2：完全匹配
     */
    #find(word){
        let cur = this.root;
        for(let c of word){
            c = c.charCodeAt(0) - 'a'.charCodeAt(0);
            if(cur.son[c] === null){
                // 道不同，不相为谋。匹配失败
                return 0;
            }
            // 继续
            cur = cur.son[c];
        }
        // 2=完全匹配 1=前缀匹配
        return cur.isEnd ? 2 : 1;
    }

    /**
     * 
     * @param {*} word 
     * 向前缀树中插入一个单词.
     * 实现方式还是比较简单的：
     * 1. 从root开始往下走，存储的字符的hash值
     * 2. 遍历字符串中每一个字符，有新节点则创建（旧节点可以共用）
     * 3. 指针的更新使用cur = cur.son[c]
     */
    insert(word){
        let cur = this.root;
        for(let c of word){
            c = c.charCodeAt(0) - 'a'.charCodeAt(0);
            if(cur.son[c] === null){
                // 当前节点没有子节点时，创建一个子节点
                cur.son[c] = new Node();
            }
            // 有了子节点之后，更新当前的root，指向当前层,也是靠这个将子节点存储下来
            cur = cur.son[c];
        }
        cur.isEnd = true;
    }

    /**
     * 
     * @param {*} word 
     * 在前缀树中查找一个单词
     */
    search(word){
        // 成功找到单词 <=>  当前节点是结束节点
        return this.#find(word) === 2;
    }
    /**
     * 
     * @param {*} prefix 
     * @return true:存在word前缀为prefix；false:不存在word以prefix为前缀
     */
    startsWith(prefix) {
        return this.#find(prefix) !== 0;
    }

}
```

