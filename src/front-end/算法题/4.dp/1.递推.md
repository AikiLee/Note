#动态规划 #递推 #leetcode
## 从记忆化搜索到递推

### (1).思考dp问题如何处理

1. 思考回溯应该怎么写：选或不选/如何枚举
2. 改为记忆化搜索，优化时间复杂度
3. 翻译成递推。递推的核心就是找到状态转移方程
### (2).以打家劫舍为例
#打家劫舍
[题目](https://leetcode.cn/problems/house-robber/description/)：
基本可以想到用dfs来处理，将问题转为一颗搜索树，这样就可以找到最大值；同样的，在过程中的dfs(i-1)就是阻止相邻。
1. 回溯的基本写法：

```ts
function rob(nums: number[]): number {

let len = nums.length;

let res = 0;

const dfs = (i)=> {

	if(i < 0) return 0;

	res = Math.max(dfs(i-1), dfs(i-2)+ nums[i]);

	return res;

}

return dfs(len-1);

};
```

这个写法可以解出问题，但是时间复杂度达到o(nlogn)，会超时

2. 使用记忆化搜索优化
使用cache数组记录计算过的dfs(i)的数据，
![[搜索树.excalidraw]]
```ts
function rob(nums: number[]): number {

let len = nums.length;
//added
const cache = new Array(len).fill(-1);

let res = 0;

const dfs = (i)=> {

	if(i < 0) return 0;
	//added
	if(cache[i] !== -1) return cache[i];
	// changed
	res = Math.max(dfs(i-1), dfs(i-2)+ nums[i]);
	// added
	cache[i] = res;
	
	return res;

}

return dfs(len-1);

};
```
3.  使用回溯
这一题的状态转移方程较为容易可以看出，就是

```ts
function rob(nums: number[]): number {

const len = nums.length;
//使用ro,r1来记录之前的信息。
let r0 = 0, r1 = 0;

for(let i = 0; i< len ;i++){

	const new_r = Math.max(r1,r0+nums[i]);
	
	r0 = r1;
	
	r1 = new_r;
	......
}

return r1;

}
```

### (3)以爬楼梯为例
#爬楼梯

继续来回顾一下如何处理dp：
- 子问题分析：选或不选/✅如何枚举，
		- 当最后一步选择1，问题就缩小为：从0/1开始，爬到n-1的台阶的最小花费
        - 当最后一步选择2，问题缩小为：从0/1开始，爬到n-2的台阶的最小花费
- 考虑状态转移方程：
	- 直接dfs，有多少条链路达到n就会自动找到
	- dfs(i-1) + dfs(i-2)
- 递归入口:
	- dfs(n)
- 优化：记忆化搜索
	- 上述代码已经可以正常运行，但是超时
	- 使用记忆化搜索对空间复杂度优化
```ts
var climbStairs = function(n) {

const cache = new Array(n+1).fill(-1);

const dfs = (i) => {

	if(i <= 1) return 1;
	
	if(cache[i] !== -1) return cache[i];
	
	return cache[i] = dfs(i-1) + dfs(i-2);

}

return dfs(n);

};
```
## 2.更多练习

[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
#打家劫舍
基本可以复用1中的代码，主要是分类讨论[0,len-1]和[1,len]
`Math.max(nums.slice(0,len-1),nums.slice(1,len));`

[746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
#爬楼梯
分析：
- 子问题分析:选或不选/✅如何枚举
	- 当最后一步选择1，问题就缩小为：从0/1开始，爬到n-1的台阶的最小花费
	- 当最后一步选择2，问题缩小为：从0/1开始，爬到n-2的台阶的最小花费
- 状态转移方程：
	- 还是基本的爬楼梯方法，总高度就是数组长度
	- dfs需要带上cost，并通过Math.min(dfs(i-1)+cost(i-1),dfs(i-2)+cost(i-2))
- 递归入口：
	- dfs(n)
- 优化：
	- 使用记忆化搜索优化

[377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)
#爬楼梯 
这题可以类似爬楼梯的处理方法。
分析：
- 子问题:选或不选/✅如何枚举
	- 使用循环+dfs来处理
- 递归过程：
	```ts
	const dfs = (i) => {
		let res = 0;
		if(i === 0) return 1;
		for(const num of nums){
			if(i<=num){
				res += dfs(i-num);
			}
		}
		return res;
	}
	```
- 递归入口：
	- dfs(target)
- 优化：
	- 记忆化搜索：正常写仍然会超时，还是得用数组来存储记录dfs计算结果

[2466. 统计构造好字符串的方案数](https://leetcode.cn/problems/count-ways-to-build-good-strings/)
#爬楼梯 
分析：
- 子问题：选或不选/✅如何枚举；本质还是爬楼梯，但是需要注意题眼：“方案数”；还需要注意求余
- 递归过程：
```ts
const dfs = (i) =>{
	if(i < 0) return 0;
	if(i === 0) return 1;
	if(memo[i] !== -1) return memo[i];
	return memo[i] = (dfs(i-zero) + dfs(i-one))%MOD;	
}
```
- 递归入口:
	- `for(let i = low; i <= high; i++)`
- 优化
	- 记忆化搜索

[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

分析：
- 子问题：✅选或不选/如何枚举；本质是打家劫舍，但是是取小；同时是二维的动态规划问题
- 递归过程：
```ts
const dfs = (i,j,grid) => {
	if(i< 0 || j <0){

	return Number.MAX_VALUE;
	
	}
	
	if(i == 0 && j==0){
	
	return grid[i][j];
	
	}
	
	// 看往下和往右移动后，谁的花费小
	
	return memo[i][j] = Math.min(dfs(i, j - 1, grid), dfs(i - 1, j, grid)) + grid[i][j];	
}
```
- 递归入口：
	 `dfs(m-1,n-1,grid)`
- 优化：
     记忆化搜索
