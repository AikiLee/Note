#背包问题 #01背包 #完全背包
## 简介

对于背包问题，在学习过程中，基本的思考过程：回溯 -> 记忆化搜索 -> 递推（一般可以1:1改写）-> 优化（空间上：二阶降为一阶）

背包问题有很多种类别，但是在这里我们介绍：`0-1背包`和`完全背包`，这二者区别不大，只是限制条件有区别：0-1背包中的物品只可以取一次，而完全背包中对应的物品则不加限制。

对于这类问题有通用解法，我们在思考问题和编写代码有思考定式：
具体可以看回溯三问：
![[回溯三问.excalidraw]]

上图展示了一般dp问题使用回溯解法的一般步骤。

### 将回溯问题改写为递推

回溯代码可以1:1翻译为递推代码，这个步骤一般比较简单：
1. 保留’递‘的过程，舍弃’归‘的过程
2. 一般需要开辟二维数组，用于存储计算过程中的结果。这里有一定的技巧：
	- 如果下标从0开始，我们习惯于使用`f[i+1][c] = f[i][c] ...` 从而避免数组越界
	- 一般结果位置为`f[n][c]`
	- 初始位置`f[0][0]=1`，这里视为一种方案，全不选
3. 考虑优化手段：一般是空间上的优化，一般两种方式：
	- 将二维数组转化为两个一维数组（不习惯）
	- 将二维转为一维：这里需要考虑计算结果被覆盖的情况。可以考虑反向计算来避免这种情况
### 引例
### 1.[494. 目标和](https://leetcode.cn/problems/target-sum/)

这是经典的01背包问题，具体的思考过程不再赘述：
1. 纯回溯做法
	```js
	function targetSumWays(nums,target){
	    let count = 0;
	    const backtrack = (nums,target,index,sum) => {
	        if(index === nums.length){
	            if(sum === target) {
	                count++;
	            }
	        }else{
	            backtrack(nums,target,index+1,sum + nums[index]);
	            backtrack(nums,target,index+1, sum - nums[index]);
	        }
	    }
	    backtrack(nums,target,0,0);
	    return count;
	}	
	```
- 时间复杂度分析：每次递归都会产生之前2倍的式子，估时间复杂度为O(2^n)
- 空间复杂度：递归层数和nums.length相关，故为O(n)
![[leetcode494.excalidraw]]
以上可以说是处理01和完全背包问题的通用解法。

## 题单

下面这些题目都是为了进一步熟悉这些解题方法

1. [2915. 和为目标值的最长子序列的长度](https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/)
这一题不要被题目骗了，不是真正的子序列问题。只是要找到和为target的组合即可。也是可以用01/完全背包问题的套路。
基本思路：
- 子问题：选了一个，在capacity中减去对应值，之后重复这样的操作，直到i<0
- 状态转移： 
	- 因为是求最大长度，需要将初始数组初始化为-Infinity，之后使用Math.max(dfs(i-1,c) ,dfs(i-1,c-nums[i])+1)
- 出入口：
	- 出口：i<0，进行判断c === 0? 0:-Infinity
	- 入口：dfs(n-1,target)
- 优化：记忆化搜索

核心代码记录：
```js
const memo = new Array(n+1).fill(0).map(()=> Array(target+1).fill(-1));
const dfs=(i,c) => {
	if(i < 0) return c === 0 ? 0 : -Infinity;
	if(nums[i] < c) memo[i][c] = dfs(i-1,c);
	if(memo[i][c] !== -1) return memo[i][c];
	return memo[i][c] = Math.max(dfs(i-1,c),dfs(i-1,c-nums[i]));
}
return dfs(n-1,target);

//转为递推
const f = new Array(n+1).fill(0).map(() => Array(target+1).fill(-Infinity));
f[0][0] = 0;
for(let i = 0 ; i< n;i++){
	for(let c = 0 ;c <= target ; c++){
		if(nums[i] > c) f[i+1][c] = f[i][c];
		else f[i+1][c] = Math.max(f[i][c] , f[i][c-nums[c]] + 1)；
	}
}
return f[n][target];

//继续优化，我们发现在循环中对i的操作是重复的，于是我们可以将i合并，只保存c，可以进一步优化
const f = new Array(target+1).fill(-Infinity);
f[0] = 0;
for(let i = 0 ; i< n ;i++){
	for(let c = target; c>=nums[i]; c--){
		f[c] = Math.max(f[c], f[c-nums[i]] + 1);
	}
}
return f[target];
```

2. [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
这一题需要先翻译题目，左右数组相等也已转换为target = sum/2。这样就转化为01背包问题。这里需要注意一点，对一这种判断是否成立的问题，使用记忆化搜索时，memo数组存储的东西也是很有讲究的。使用或运算，保证将非零数据（js中0为false）存储起来。
```js
const memo = new Array(n+1).fill(0).map(() => Array(target+1).fill(-1));
const dfs = (i,c) => {
	if(i<0) return c===0 ? true : false;
	if(memo[i][c] !== -1) return memo[i][c];
	const res = c >= nums[i] && dfs(i-1,c-nums[i]) || dfs(i-1,c);
	memo[i][c] = res ? true : false;
	return res;
}
return dfs(n-1,target);

/*
  翻译为递推：
  舍弃’递‘的过程，保留’归‘的过程
*/
for(let i = 0 ; i<n ;i++){
	const x = nums[i];
	for(let j = 0 ; j <= target ; j++){
		f[i+1][j] = j >= x && f[i][j-x] || f[i][j];

	}
}
return f[n][target];

/*
	进一步优化：将二维数组优化为一维，降低空间复杂度
	时间复杂度O(n* target); 空间复杂度O(target)
*/
const f = new Array(target+1).fill(false);
	f[0] = true;
	for(let i = 0 ; i< n; i++){
	const x = nums[i];
	for(let j = target ; j>= x; j--){
		f[j] = f[j] || f[j - x];
	}
return f[target];
```


3. [2787. 将一个数字表示成幂的和的方案数](https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/)
也是模板题，直接思考递归反而不太好想

4. [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)
类题：[322. 零钱兑换](https://leetcode.cn/problems/coin-change/)
模板题：现在需要干的事就是固化思考模式。
读题：完全背包问题；coins是递增数组；考虑使用Math.min，但是为了保证结果对失败结果可以设置为Infinity / 2 + 1
子问题：模板题，选一个硬币，之后将amount减去对应值；可以重复选
状态转移：Math.min(dfs(i-1,c),dfs(i,c-coins[i]) + 1) 不选和选重复的
递归边界： dfs(-1,0) -> 0 ; dfs(-1, not 0) Infinity
递归入口：dfs(n-1,amount)
```js
//回溯做法
const dfs = (i,c) => {
	if(i<0) return c===0 ? 0 : Infinity / 2 + 1;
	if(memo[i][c] !== -1 ) return memo[i][c];	
	if(coins[i] > c) return memo[i][c] = dfs(i-1,c);
	return memo[i][c] = Math.min(dfs(i-1,c),dfs(i,c-coins[i])+1);
}
let ans = dfs(n-1,amount);
return ans === Infinity / 2 + 1 ? -1 : ans;

//改为递推
const f= new Array(n+1).fill(0).map(() => Array(amount+1).fill(0));
f[0][0] = 1;
for(let i = 0 ; i< n ;i++){
	for(let c = 0 ; c <= amount ; c++){
		if(coins[i] > c) f[i+1][c] = f[i][c];
		else f[i+1][c] = f[i][c] + f[i+1][c-coins[i]];
	}
}
return f[n][amount];

//空间优化,将二维数组降为一阶，因为对i的操作是相同的，本质是用一维数组模拟二维数组的操作。但是这里有一个问题:为什么这里可以使用正序，而不会被覆盖，我的想法是i错位了f[i+1][c] = f[i][c] + f[i+1][c-coins[i]];
const f = new Array(amount+1).fill(0);
f[0] = 1;
for(let x of coins){
	for(let c = x; c<= amount ; c++){
		f[c] += f[c-x];
		//这里可以有多种变式，若是求最大最小，则变成f[c] = Math.max(f[c],f[c-x])
	}

}




```


5. [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)
