import{_ as a,c as t,o as r,af as i}from"./chunks/framework.W5ZyBR1w.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/面试/1.网络.md","filePath":"front-end/面试/1.网络.md"}'),l={name:"front-end/面试/1.网络.md"};function o(n,e,s,d,h,c){return r(),t("div",null,[...e[0]||(e[0]=[i('<p>对于八股文的回答，我们可以从五个层次上回答：</p><ol><li>是什么，最好使用专业术语来描述这个问题，使回答专业化</li><li>为什么，需要较为深入理解这个问题，例如v-for为什么要加key，就要追踪到vue的diff算法，加key可以优化渲染效率，减少dom更新次数，减少出错的概率：因为vue使用虚拟dom，其和真实数据之间的映射是通过xxx维护的，如果不加key，vue就倾向于修改内容，而非移动dom元素</li><li>怎么做，在具体的操作中可能会引出的问题，何时用何时不用：加什么key，是使用index还是一个新字段，正确的做法是加唯一标识，因为如果这个列表涉及修改删除排序之类的操作，那么就会引入index的变动导致渲染错误，以至于失去功能。因此对于纯静态展示的页面，加不加影响不大，其他情况都应该加</li><li>结合自己的具体操作情况：例如，在自己的项目中，当时是一个动态的问卷表单，用户可以添加或删除问题。我们最初不规范地使用了 index 作为 key。当用户删除中间的一个问题时，下面所有问题的用户输入内容和校验状态都错位了。通过 Debug，我们发现是 Vue 复用了组件实例导致的。后来将 key 统一改成问题自身的唯一 questionId，问题就解决了。那次经历让我深刻理解到，key 的核心是<strong>身份识别 (identity)</strong>，而不仅仅是性能优化 (performance)</li></ol><h2 id="_1-http-https" tabindex="-1">1.HTTP/HTTPS <a class="header-anchor" href="#_1-http-https" aria-label="Permalink to “1.HTTP/HTTPS”">​</a></h2><p><code>http</code>:是基于tcp的用于在客户端和服务器之间传输超文本的协议 <code>https</code>:由于http传输信息是明文的，数据在传输中容易被窃取和修改，所以在此基础上，对数据采用tls/ssl加密，保证传输的可靠，</p><h2 id="_2-https的工作原理" tabindex="-1">2.HTTPS的工作原理 <a class="header-anchor" href="#_2-https的工作原理" aria-label="Permalink to “2.HTTPS的工作原理”">​</a></h2><ol><li>客户端使用https协议访问，就会请求和web服务器建立<code>ssl</code>链接</li><li>server收到请求之后，就会将网站证书(包含公钥)传递给客户端</li><li>客户端服务端协商ssl加密等级</li><li>协商完成，建立会话密钥，一般是使用服务器的公钥来加密会话</li><li>服务器通过自己的私钥来解密会话</li></ol><h2 id="_3-tcp三次握手和四次挥手" tabindex="-1">3.TCP三次握手和四次挥手 <a class="header-anchor" href="#_3-tcp三次握手和四次挥手" aria-label="Permalink to “3.TCP三次握手和四次挥手”">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to “三次握手”">​</a></h3><p>1：建立连接时，client会发送SYN=1(同步序列编号)，seq=j，发送之后会进入到SYN_SENT状态 2：server接收到请求后，会响应一个SYN = 1, ACK = 1， seq=k, ack = j+1的报文，发送之后进入到SYN_RVID 3：client在接受到响应之后，再次发送一个ACK=1, ack=k+1的报文，确认应答。此时server的状态是ESTABISHED</p><p>Q1：为什么要发第三次请求？ 为了防止重复建立连接，浪费服务器资源。因为网络是不稳定有波动的，如果之前的连接建立请求报文，因为网络延时而到达，此刻如果只有两次，就会重复建立连接。</p><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to “四次挥手”">​</a></h3><p>1：client请求断开连接，发送一个FIN=1，seq=j的报文，进入FIN_WAIT1 2：server响应报文ACK=1,ack=j+1，seq=k之后进入CLOSE_WAIT状态 3：client接受响应报文，进入FIN_WAIT2。之后server发送连接释放报文，FIN=1,ACK=1,seq=z,ack=j+1,之后进入LAST_ACK状态 4：client响应报文，ACK=1,ack=z+1,seq=j+1，进入TIME_WAIT状态；server接收到报文之后直接进入CLOSED状态；最后2MSL之后client才会进入closed状态</p><p>Q1: 为什么 TCP 关闭连接为什么要四次而不是三次？ 服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段，接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。</p><p>Q2：客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？ 网络并不总是可靠的，如果客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 报文段。因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间，如果在此期间又收到了来自服务器的 FIN 报文段，那么客户端会重新设置计时器并再次等待 2MSL 的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了</p><h2 id="_4-tcp-udp" tabindex="-1">4.TCP/UDP <a class="header-anchor" href="#_4-tcp-udp" aria-label="Permalink to “4.TCP/UDP”">​</a></h2><p><code>TCP</code>:TCP 是<strong>面向连接</strong>的、<strong>可靠</strong>的流协议。常用于：http，ftp，smtp <code>UDP</code>:无连接，不可靠具体的处理交给应用层处理，面向报文。长用于：dns，音视频，广播</p><h2 id="_5-get-post" tabindex="-1">5.GET/POST <a class="header-anchor" href="#_5-get-post" aria-label="Permalink to “5.GET/POST”">​</a></h2><p>Q: 请讲一讲二者区别 ANS：</p><ol><li>参数位置：get请求参数放在url中直接显示，post则是放在请求体中。</li><li>对参数的长度支持不同，http协议对body中携带的参数没有长度限制，但是浏览器一般会对url长度有限制，而且不尽相同。例如<code>IE</code>:2083B</li><li>浏览器处理发送的方式不同，对于大多数浏览器，处理get请求，会直接将<code>http-header</code>和<code>data</code>一起发送。而对于post则会先发送<code>header</code>,服务器响应100-continue，才会继续返回data。FireFox则不同，会直接发送。如果响应的不是100，需要等待并处理服务器的最终响应。</li></ol><h2 id="_6-https是如何保证安全的" tabindex="-1">6.HTTPS是如何保证安全的 <a class="header-anchor" href="#_6-https是如何保证安全的" aria-label="Permalink to “6.HTTPS是如何保证安全的”">​</a></h2><p>http面临的风险主要是：</p><ol><li><strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</li><li><strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</li><li><strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</li></ol><p>因此，SSL/TLS 协议就是为了解决这三大风险而设计的，希望达到：</p><ol><li>所有信息都是<strong>加密传播</strong>，第三方无法窃听。</li><li>具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</li><li>配备<strong>身份证书</strong>，防止身份被冒充。</li></ol><h3 id="_1-会话加密" tabindex="-1">（1）会话加密 <a class="header-anchor" href="#_1-会话加密" aria-label="Permalink to “（1）会话加密”">​</a></h3><p>https的基本思路就是客户端会向服务端所要公钥（一般ca证书中就包含），并采用这个公钥来加密会话。服务端收到信息之后，会用自己的私钥来解密。</p><h3 id="_2-保证公钥不被修改" tabindex="-1">（2）保证公钥不被修改 <a class="header-anchor" href="#_2-保证公钥不被修改" aria-label="Permalink to “（2）保证公钥不被修改”">​</a></h3><p>将公钥放在<a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Digital_certificate" target="_blank" rel="noreferrer">数字证书</a>中。只要证书是可信的，公钥就是可信的。这里的利用了ca证书进行检验</p><h3 id="_3-身份冒充" tabindex="-1">（3）身份冒充 <a class="header-anchor" href="#_3-身份冒充" aria-label="Permalink to “（3）身份冒充”">​</a></h3><p>利用ca证书的信任链。</p>',30)])])}const T=a(l,[["render",o]]);export{_ as __pageData,T as default};
