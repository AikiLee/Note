import{_ as a,c as r,o as t,af as n}from"./chunks/framework.W5ZyBR1w.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/算法题/tech/2.单调栈，队列.md","filePath":"front-end/算法题/tech/2.单调栈，队列.md"}'),_={name:"front-end/算法题/tech/2.单调栈，队列.md"};function o(l,e,h,i,s,c){return t(),r("div",null,[...e[0]||(e[0]=[n('<p>这些也是常见的优化手段，对于一些问题，我们可能在子区间内部重复的去求最值，往往时间复杂度可以达到O(n^2)，使用单调栈，队列，可以借助部分存储空间来暂存区间最值，从而将时间复杂度降为O(n)</p><h2 id="模板题" tabindex="-1">模板题 <a class="header-anchor" href="#模板题" aria-label="Permalink to “模板题”">​</a></h2><h3 id="_739-每日温度" tabindex="-1"><a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank" rel="noreferrer">739. 每日温度</a> <a class="header-anchor" href="#_739-每日温度" aria-label="Permalink to “739. 每日温度”">​</a></h3><p>这一题的暴力做法很容易想到： 利用双层循环，记录每层遇到的第一个更大值，但是超时。 又是一个求局部最值的问题，我们很自然地想到，可以使用单调栈来再试存储当前的最大值，仅在出现更大值时出栈并计算距离。</p><h3 id="_84-柱状图中最大的矩形" tabindex="-1"><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noreferrer">84. 柱状图中最大的矩形</a> <a class="header-anchor" href="#_84-柱状图中最大的矩形" aria-label="Permalink to “84. 柱状图中最大的矩形”">​</a></h3><p>暴力做法也是比较容易想到的：使用三重循环，分别找到height和width，计算面积最大值。 现在来思考，如何优化：依然从枚举触发，高度是确定的，其在height[i]中枚举，底边长度是否可以通过一种数据结构来操作从而计算。 先来看一下经典问题「求最近一个比当前值大的位置」</p>',6)])])}const f=a(_,[["render",o]]);export{p as __pageData,f as default};
