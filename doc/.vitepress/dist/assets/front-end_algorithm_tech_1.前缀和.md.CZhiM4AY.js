import{_ as a,c as r,o as t,ah as n}from"./chunks/framework.C2T-hxF6.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/algorithm/tech/1.前缀和.md","filePath":"front-end/algorithm/tech/1.前缀和.md"}'),o={name:"front-end/algorithm/tech/1.前缀和.md"};function l(_,e,c,h,i,s){return t(),r("div",null,[...e[0]||(e[0]=[n('<p>这也是一种解题技巧，而不是具体的题型分类。在要求时间复杂度的题目中，可能有奇效</p><h2 id="例题" tabindex="-1">例题 <a class="header-anchor" href="#例题" aria-label="Permalink to “例题”">​</a></h2><h3 id="_238-除自身以外数组的乘积" tabindex="-1"><a href="https://leetcode.cn/problems/product-of-array-except-self/" target="_blank" rel="noreferrer">238. 除自身以外数组的乘积</a> <a class="header-anchor" href="#_238-除自身以外数组的乘积" aria-label="Permalink to “238. 除自身以外数组的乘积”">​</a></h3><p>常规做法肯定是使用双重循环来处理。但是题目要求时间复杂度为O(N)考虑使用空间换时间，利用乘法结合律，分别计算出不同段的乘积，再相乘。</p><h3 id="_42-接雨水" tabindex="-1"><a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noreferrer">42. 接雨水</a> <a class="header-anchor" href="#_42-接雨水" aria-label="Permalink to “42. 接雨水”">​</a></h3><p>也是比较经典的题目。需要使用前后缀和来保存当前位置的最大/小值，便于计算能接住的雨水面积。</p>',6)])])}const f=a(o,[["render",l]]);export{p as __pageData,f as default};
