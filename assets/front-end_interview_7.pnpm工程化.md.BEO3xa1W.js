import{_ as t,c as n,o,ah as r}from"./chunks/framework.BEigD8kW.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/interview/7.pnpm工程化.md","filePath":"front-end/interview/7.pnpm工程化.md"}'),i={name:"front-end/interview/7.pnpm工程化.md"};function a(l,e,s,_,p,d){return o(),n("div",null,[...e[0]||(e[0]=[r('<p>为什么要工程化，就是为了解决四个问题</p><ol><li>统一打包</li><li>统一发布</li><li>依赖优化</li><li>统一测试</li></ol><h2 id="web性能优化" tabindex="-1">web性能优化 <a class="header-anchor" href="#web性能优化" aria-label="Permalink to “web性能优化”">​</a></h2><ol><li><strong>网络层面：</strong> “比如减少 HTTP 请求（雪碧图、合并文件）、使用 CDN 加速静态资源、对资源启用 Gzip 压缩、使用 HTTP/2 协议、设置合理的浏览器缓存策略（Cache-Control, Expires）等。”</li><li><strong>资源层面：</strong> “主要是指代码和图片。对图片进行压缩、使用 WebP 格式、图片懒加载。对代码进行 Tree Shaking 移除死代码、代码分割（Code Splitting）实现按需加载、压缩 JS 和 CSS 代码。”</li><li><strong>渲染层面：</strong> “关键是减少浏览器的回流(Reflow)和重绘(Repaint)。比如 CSS 选择器层级不要太深、避免使用<code> &lt;table&gt;</code> 布局、将 JS 脚本放在 <code>&lt;body&gt;</code> 底部防止阻塞 DOM 解析、对频繁变动的元素开启硬件加速（如 transform: translateZ(0)）。”</li></ol>',4)])])}const f=t(i,[["render",a]]);export{m as __pageData,f as default};
