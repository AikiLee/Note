import{_ as r,c as a,o as i,ah as t}from"./chunks/framework.BEigD8kW.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/interview/6.Vue.md","filePath":"front-end/interview/6.Vue.md"}'),n={name:"front-end/interview/6.Vue.md"};function o(s,e,l,h,p,u){return i(),a("div",null,[...e[0]||(e[0]=[t(`<p><a href="https://www.nowcoder.com/discuss/500111803020488704?sourceSSR=dynamic" target="_blank" rel="noreferrer">https://www.nowcoder.com/discuss/500111803020488704?sourceSSR=dynamic</a><a href="https://vue3js.cn/interview/" target="_blank" rel="noreferrer">https://vue3js.cn/interview/</a></p><h2 id="_1-mvvm" tabindex="-1">1. MVVM <a class="header-anchor" href="#_1-mvvm" aria-label="Permalink to “1. MVVM”">​</a></h2><h2 id="_2-vue优缺点" tabindex="-1">2.Vue优缺点 <a class="header-anchor" href="#_2-vue优缺点" aria-label="Permalink to “2.Vue优缺点”">​</a></h2><h2 id="_3-vue-diff算法" tabindex="-1">3.Vue Diff算法 <a class="header-anchor" href="#_3-vue-diff算法" aria-label="Permalink to “3.Vue Diff算法”">​</a></h2><h2 id="_4-vue生命周期" tabindex="-1">4.vue生命周期 <a class="header-anchor" href="#_4-vue生命周期" aria-label="Permalink to “4.vue生命周期”">​</a></h2><h2 id="_5-compute和watch" tabindex="-1">5.compute和watch <a class="header-anchor" href="#_5-compute和watch" aria-label="Permalink to “5.compute和watch”">​</a></h2><h2 id="_6-为什么-v-for-和-v-if-不建议用在一起" tabindex="-1">6.为什么 v-for 和 v-if 不建议用在一起 <a class="header-anchor" href="#_6-为什么-v-for-和-v-if-不建议用在一起" aria-label="Permalink to “6.为什么 v-for 和 v-if 不建议用在一起”">​</a></h2><h2 id="_7-key的作用" tabindex="-1">7. key的作用 <a class="header-anchor" href="#_7-key的作用" aria-label="Permalink to “7. key的作用”">​</a></h2><h2 id="_8-组件通信方式" tabindex="-1">8.组件通信方式 <a class="header-anchor" href="#_8-组件通信方式" aria-label="Permalink to “8.组件通信方式”">​</a></h2><p>父传子：props, 子传父： emit，跨级别传输：inject/provide , 统一的状态维护：vuex/pinia, 兄弟之间通信：Eventbus/父组件中转/共享响应式</p><h2 id="_9-nexttick原理" tabindex="-1">9.nextTick原理 <a class="header-anchor" href="#_9-nexttick原理" aria-label="Permalink to “9.nextTick原理”">​</a></h2><p>在 DOM 更新之后执行回调，并且 Vue 的 DOM 更新是异步的。</p><ul><li><p><strong>补充“为什么”：</strong> “Vue 之所以异步更新 DOM，是为了性能优化。当我们在一个事件循环中多次修改响应式数据时，Vue 不会每次都去操作 DOM，而是会将这些修改缓存到一个队列中，在下一个‘tick’统一执行，从而避免了不必要的 DOM 操作。”</p></li><li><p><strong>补充“怎么做”：</strong> “nextTick 的原理就是将我们传入的回调函数也放进这个异步更新队列的末尾。它内部会优雅降级地尝试使用 Promise.then (微任务)、MutationObserver (微任务)，如果环境不支持，最后会使用 setTimeout(..., 0) (宏任务) 来实现。这样就保证了我们的代码一定会在 Vue 完成 DOM 更新之后执行。” (能提到微任务和宏任务会非常加分)</p></li></ul><h2 id="_10-插槽-具名插槽" tabindex="-1">10.插槽，具名插槽 <a class="header-anchor" href="#_10-插槽-具名插槽" aria-label="Permalink to “10.插槽，具名插槽”">​</a></h2><h2 id="_11-keepalive" tabindex="-1">11.keepalive <a class="header-anchor" href="#_11-keepalive" aria-label="Permalink to “11.keepalive”">​</a></h2><h2 id="_12-mixin" tabindex="-1">12.mixin <a class="header-anchor" href="#_12-mixin" aria-label="Permalink to “12.mixin”">​</a></h2><h2 id="_13-v-for中的key" tabindex="-1">13.v-for中的key <a class="header-anchor" href="#_13-v-for中的key" aria-label="Permalink to “13.v-for中的key”">​</a></h2><ol><li><p><strong>是什么 (What):</strong><br> key 是 Vue 在 v-for 循环中，为每个虚拟 DOM 节点 (VNode) 提供的唯一标识。它本质上是给 Diff 算法的一个提示，以帮助其更高效、更准确地识别节点。</p></li><li><p><strong>为什么 (Why):</strong><br> 这要从 Vue 的 Diff 算法说起。<strong>Vue 的默认更新策略是“就地更新 (in-place patch)”</strong>，这是一种性能优化。如果没有 key，当列表顺序变化时，Vue 不会移动 DOM 元素，而是就地修改每个元素的内容以匹配新数据。对于纯展示的列表这没有问题，但如果列表项是组件或包含临时状态（如 <input> 的输入值），这种策略就会导致状态错乱。key 的存在，就强制 Diff 算法从“就地更新”模式切换到“<strong>基于 key 的身份识别</strong>”模式，从而进行移动、创建或销毁操作，保证了数据和状态的正确对应。</p></li><li><p><strong>怎么做 (How):</strong></p><ul><li><p><strong>何时使用：</strong> 只要 v-for 渲染的列表未来可能发生顺序变化、删除、插入等非末尾操作，或者列表项是组件、包含表单元素等内部状态时，就<strong>必须</strong>使用 key。</p></li><li><p><strong>如何选择：</strong> key 值必须是<strong>稳定且唯一</strong>的字符串或数字。最佳选择是数据项自带的唯一 ID，比如 item.id。</p></li><li><p><strong>反模式：</strong> <strong>绝对不要使用 index 作为动态列表的 key</strong>。因为当数组发生删除或在中间插入元素时，元素的 index 会改变，key 也就失去了其“稳定”的特性，这会导致和不加 key 时同样的状态错乱问题，并可能引发更难察觉的 bug，完全违背了使用 key 的初衷。</p></li></ul></li><li><p><strong>我的实践 (Experience):</strong><br> 在我之前的一个项目中，就踩过这个坑。当时是一个动态的问卷表单，用户可以添加或删除问题。我们最初不规范地使用了 index 作为 key。当用户删除中间的一个问题时，下面所有问题的用户输入内容和校验状态都错位了。通过 Debug，我们发现是 Vue 复用了组件实例导致的。后来将 key 统一改成问题自身的唯一 questionId，问题就解决了。那次经历让我深刻理解到，<strong>key 的核心是身份识别 (identity)，其优先级甚至高于性能优化 (performance)</strong>。</p></li></ol><h2 id="_14-vue-router" tabindex="-1">14.vue router <a class="header-anchor" href="#_14-vue-router" aria-label="Permalink to “14.vue router”">​</a></h2><h3 id="hash和history模式区别" tabindex="-1">hash和history模式区别 <a class="header-anchor" href="#hash和history模式区别" aria-label="Permalink to “hash和history模式区别”">​</a></h3><p>vue router的区别体现在url的表现形式上，在hash模式下会在host之后加上#，后面的内容成为哈希值，不会发送到服务器上，浏览器根据hash值来渲染不同的组件；而在history模式中，url不含#，更接近传统路径。</p><pre><code>- 究其原因在hash模式下，vue router会根据浏览器的hashchange事件来处理url的哈希值，当其发生变化时，就会根据新的hash值来生成组件，并且这种变化不会向服务器发送请求，所以在spa应用中非常方便 ；而history模式基于HMTL5的history api(pushState, replaceState)，vue会调用对应的浏览器方法来更新历史记录，同时渲染组件。同时在history模式中，需要服务器做额外的配置，将所有的路径重定向到入口文件
    
- 那么如何选择这两种方式呢：对于需要兼容所有浏览器的情况，推荐hash模式，其支持所有，history模式依赖html5 history api，不支持ie9以下；同时如果需要对网站seo的话，hash过后的内容不会被搜索引擎爬虫抓取，而histroy模式下，url更加直接，更方便搜索引擎解析。综上，hash模式更适合无需服务器配置的静态站点，或者兼容老旧浏览器的项目，history模式适合追求url美观的现代web应用
</code></pre><h3 id="vue-router-懒加载" tabindex="-1">Vue Router 懒加载 <a class="header-anchor" href="#vue-router-懒加载" aria-label="Permalink to “Vue Router 懒加载”">​</a></h3><p>“Vue Router 的懒加载是通过 <strong>ES6 的动态导入 import() 语法</strong>实现的。在路由配置中，component 选项不再直接引用组件对象，而是改为一个返回 import() 调用的函数，例如 component: () =&gt; import(&#39;@/views/Home.vue&#39;)。当路由被访问时，这个函数才会被执行。Webpack 或 Vite 这类现代构建工具在遇到这种语法时，会自动进行<strong>代码分割</strong>，将这个组件及其依赖打包成一个独立的 chunk 文件。这样做最大的好处是，只有当用户访问某个特定路由时，浏览器才会去下载对应的 JS chunk，从而<strong>显著减小了应用入口文件的体积，缩短了首屏加载和解析时间</strong>，提升了用户体验。”</p><h3 id="动态路由" tabindex="-1">动态路由 <a class="header-anchor" href="#动态路由" aria-label="Permalink to “动态路由”">​</a></h3><h3 id="pinia-vs-vuex" tabindex="-1"><strong>Pinia vs. Vuex</strong> <a class="header-anchor" href="#pinia-vs-vuex" aria-label="Permalink to “Pinia vs. Vuex”">​</a></h3><ol><li><p><strong>是什么:</strong> Pinia 是 Vue 官方推荐的新一代状态管理库，可以看作是 Vuex 5 的事实标准。</p></li><li><p><strong>为什么:</strong> Pinia 的出现是为了解决 Vuex 在 Composition API 和 TypeScript 整合上的一些痛点，并提供更简洁、更直观的开发体验。</p></li><li><p><strong>怎么做:</strong> Pinia 的优势体现在：</p><ul><li><p><strong>API 极其简洁：</strong> 废除了 mutations，可以直接在 actions 中修改 state，心智负担小。</p></li><li><p><strong>完美的 TS 支持：</strong> 无需复杂的类型体操就能获得完整的类型自动推导。</p></li><li><p><strong>模块化更直观：</strong> 每个 store 都是独立的模块，按需导入使用即可，不再有全局的 modules 注册。</p></li><li><p><strong>体积更小，对摇树优化更友好。</strong></p></li></ul></li><li><p><strong>我的实践:</strong> 在一个新项目中，我们从一开始就选择了 Pinia。最直观的感受是，定义一个 store 就像定义一个 reactive 对象一样简单，并且在组件的 setup 中使用时，类型提示非常完美，几乎没有遇到任何类型问题，开发效率相比之前使用 Vuex + TS 的项目有了显著提升。</p></li></ol><h3 id="vue-router路由导航" tabindex="-1">vue router路由导航 <a class="header-anchor" href="#vue-router路由导航" aria-label="Permalink to “vue router路由导航”">​</a></h3><ol><li><p><strong>是什么:</strong> Vue Router 的导航守卫是一套钩子函数，允许我们在路由跳转的不同阶段（进入前、确认前、离开后等）执行自定义逻辑，是实现路由权限控制、登录校验等功能的标准机制。</p></li><li><p><strong>为什么:</strong> 将权限逻辑集中在导航守卫中，可以实现与业务组件的解耦。我们无需在每个需要权限的组件内部都写一遍重复的校验逻辑，使得代码更易于维护和扩展。</p></li><li><p><strong>怎么做:</strong> 最佳实践是使用<strong>全局前置守卫 router.beforeEach</strong>。</p><ol><li><p>为路由配置添加 meta 字段，标记需要认证的路由：meta: { requiresAuth: true }。</p></li><li><p>在 beforeEach 中，检查 to.meta.requiresAuth。</p></li><li><p>如果需要认证，则检查 Pinia 或 localStorage 中是否存在 token。</p></li><li><p>若已登录，调用 next() 放行。</p></li><li><p>若未登录，调用 next({ path: &#39;/login&#39;, query: { redirect: to.fullPath } }) 重定向到登录页。</p></li><li><p>对于不需要认证的路由（白名单），直接 next()。</p></li></ol></li></ol><h2 id="_15-pinia" tabindex="-1">15 pinia <a class="header-anchor" href="#_15-pinia" aria-label="Permalink to “15 pinia”">​</a></h2><h3 id="pinia-的-actions-vs-getters" tabindex="-1"><strong>Pinia 的 actions vs. getters</strong> <a class="header-anchor" href="#pinia-的-actions-vs-getters" aria-label="Permalink to “Pinia 的 actions vs. getters”">​</a></h3><ul><li><p><strong>优点:</strong> 核心区别概括得非常到位：“actions 更多是封装函数，处理异步和业务逻辑；getters 更像是 computed，用于派生计算属性”。这已经抓住了问题的精髓。</p></li><li><p><strong>可改进之处:</strong> 可以补充一下 getters 的一个重要特性——<strong>缓存</strong>。</p></li><li><p><strong>修改建议:</strong> 在您的回答后补充一句：“getters 和 computed 一样，其结果会被缓存。只要它依赖的 state 没有发生变化，多次访问 getter 都会立即返回之前缓存的结果，而不会重新计算，这是一种性能优化。而 actions 每次调用都会执行。”</p></li></ul><h3 id="pinia-数据持久化" tabindex="-1"><strong>Pinia 数据持久化</strong> <a class="header-anchor" href="#pinia-数据持久化" aria-label="Permalink to “Pinia 数据持久化”">​</a></h3><ul><li><p><strong>优点:</strong> 您直接给出了最佳实践方案——使用 Pinia 插件。思路清晰，核心点 ($subscribe 监听 和 初始化时读取) 都提到了。</p></li><li><p><strong>可改进之处:</strong> 可以提及有现成的库可以简化这个过程，体现您的视野广度。</p></li><li><p><strong>修改建议:</strong> 在您的回答最后可以补充：“当然，这个逻辑已经有成熟的开源插件了，比如 pinia-plugin-persistedstate，在实际项目中，我们通常会直接使用这类插件，而不是自己手写，这样更高效、更健壮。”</p></li></ul>`,34)])])}const g=r(n,[["render",o]]);export{d as __pageData,g as default};
