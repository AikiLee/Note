https://www.nowcoder.com/discuss/500111803020488704?sourceSSR=dynamic
https://vue3js.cn/interview/
## 1. MVVM

## 2.Vue优缺点

## 3.Vue Diff算法

## 4.vue生命周期

## 5.compute和watch

## 6.为什么 v-for 和 v-if 不建议用在一起

## 7. key的作用

## 8.组件通信方式

父传子：props, 子传父： emit，跨级别传输：inject/provide , 统一的状态维护：vuex/pinia, 兄弟之间通信：Eventbus/父组件中转/共享响应式
## 9.nextTick原理

在 DOM 更新之后执行回调，并且 Vue 的 DOM 更新是异步的。
- **补充“为什么”：** “Vue 之所以异步更新 DOM，是为了性能优化。当我们在一个事件循环中多次修改响应式数据时，Vue 不会每次都去操作 DOM，而是会将这些修改缓存到一个队列中，在下一个‘tick’统一执行，从而避免了不必要的 DOM 操作。”
    
- **补充“怎么做”：** “nextTick 的原理就是将我们传入的回调函数也放进这个异步更新队列的末尾。它内部会优雅降级地尝试使用 Promise.then (微任务)、MutationObserver (微任务)，如果环境不支持，最后会使用 setTimeout(..., 0) (宏任务) 来实现。这样就保证了我们的代码一定会在 Vue 完成 DOM 更新之后执行。” (能提到微任务和宏任务会非常加分)

## 10.插槽，具名插槽

## 11.keepalive

## 12.mixin

## 13.v-for中的key

1. **是什么 (What):**  
    key 是 Vue 在 v-for 循环中，为每个虚拟 DOM 节点 (VNode) 提供的唯一标识。它本质上是给 Diff 算法的一个提示，以帮助其更高效、更准确地识别节点。
    
2. **为什么 (Why):**  
    这要从 Vue 的 Diff 算法说起。**Vue 的默认更新策略是“就地更新 (in-place patch)”**，这是一种性能优化。如果没有 key，当列表顺序变化时，Vue 不会移动 DOM 元素，而是就地修改每个元素的内容以匹配新数据。对于纯展示的列表这没有问题，但如果列表项是组件或包含临时状态（如 <input> 的输入值），这种策略就会导致状态错乱。key 的存在，就强制 Diff 算法从“就地更新”模式切换到“**基于 key 的身份识别**”模式，从而进行移动、创建或销毁操作，保证了数据和状态的正确对应。
    
3. **怎么做 (How):**
    
    - **何时使用：** 只要 v-for 渲染的列表未来可能发生顺序变化、删除、插入等非末尾操作，或者列表项是组件、包含表单元素等内部状态时，就**必须**使用 key。
        
    - **如何选择：** key 值必须是**稳定且唯一**的字符串或数字。最佳选择是数据项自带的唯一 ID，比如 item.id。
        
    - **反模式：** **绝对不要使用 index 作为动态列表的 key**。因为当数组发生删除或在中间插入元素时，元素的 index 会改变，key 也就失去了其“稳定”的特性，这会导致和不加 key 时同样的状态错乱问题，并可能引发更难察觉的 bug，完全违背了使用 key 的初衷。
        
4. **我的实践 (Experience):**  
    在我之前的一个项目中，就踩过这个坑。当时是一个动态的问卷表单，用户可以添加或删除问题。我们最初不规范地使用了 index 作为 key。当用户删除中间的一个问题时，下面所有问题的用户输入内容和校验状态都错位了。通过 Debug，我们发现是 Vue 复用了组件实例导致的。后来将 key 统一改成问题自身的唯一 questionId，问题就解决了。那次经历让我深刻理解到，**key 的核心是身份识别 (identity)，其优先级甚至高于性能优化 (performance)**。
## 14.vue router

### hash和history模式区别

 vue router的区别体现在url的表现形式上，在hash模式下会在host之后加上#，后面的内容成为哈希值，不会发送到服务器上，浏览器根据hash值来渲染不同的组件；而在history模式中，url不含#，更接近传统路径。
    
    - 究其原因在hash模式下，vue router会根据浏览器的hashchange事件来处理url的哈希值，当其发生变化时，就会根据新的hash值来生成组件，并且这种变化不会向服务器发送请求，所以在spa应用中非常方便 ；而history模式基于HMTL5的history api(pushState, replaceState)，vue会调用对应的浏览器方法来更新历史记录，同时渲染组件。同时在history模式中，需要服务器做额外的配置，将所有的路径重定向到入口文件
        
    - 那么如何选择这两种方式呢：对于需要兼容所有浏览器的情况，推荐hash模式，其支持所有，history模式依赖html5 history api，不支持ie9以下；同时如果需要对网站seo的话，hash过后的内容不会被搜索引擎爬虫抓取，而histroy模式下，url更加直接，更方便搜索引擎解析。综上，hash模式更适合无需服务器配置的静态站点，或者兼容老旧浏览器的项目，history模式适合追求url美观的现代web应用

### Vue Router 懒加载
    
“Vue Router 的懒加载是通过 **ES6 的动态导入 import() 语法**实现的。在路由配置中，component 选项不再直接引用组件对象，而是改为一个返回 import() 调用的函数，例如 component: () => import('@/views/Home.vue')。当路由被访问时，这个函数才会被执行。Webpack 或 Vite 这类现代构建工具在遇到这种语法时，会自动进行**代码分割**，将这个组件及其依赖打包成一个独立的 chunk 文件。这样做最大的好处是，只有当用户访问某个特定路由时，浏览器才会去下载对应的 JS chunk，从而**显著减小了应用入口文件的体积，缩短了首屏加载和解析时间**，提升了用户体验。”
### 动态路由


### **Pinia vs. Vuex**

1. **是什么:** Pinia 是 Vue 官方推荐的新一代状态管理库，可以看作是 Vuex 5 的事实标准。
    
2. **为什么:** Pinia 的出现是为了解决 Vuex 在 Composition API 和 TypeScript 整合上的一些痛点，并提供更简洁、更直观的开发体验。
    
3. **怎么做:** Pinia 的优势体现在：
    
    - **API 极其简洁：** 废除了 mutations，可以直接在 actions 中修改 state，心智负担小。
        
    - **完美的 TS 支持：** 无需复杂的类型体操就能获得完整的类型自动推导。
        
    - **模块化更直观：** 每个 store 都是独立的模块，按需导入使用即可，不再有全局的 modules 注册。
        
    - **体积更小，对摇树优化更友好。**
        
4. **我的实践:** 在一个新项目中，我们从一开始就选择了 Pinia。最直观的感受是，定义一个 store 就像定义一个 reactive 对象一样简单，并且在组件的 setup 中使用时，类型提示非常完美，几乎没有遇到任何类型问题，开发效率相比之前使用 Vuex + TS 的项目有了显著提升。

### vue router路由导航

1. **是什么:** Vue Router 的导航守卫是一套钩子函数，允许我们在路由跳转的不同阶段（进入前、确认前、离开后等）执行自定义逻辑，是实现路由权限控制、登录校验等功能的标准机制。
    
2. **为什么:** 将权限逻辑集中在导航守卫中，可以实现与业务组件的解耦。我们无需在每个需要权限的组件内部都写一遍重复的校验逻辑，使得代码更易于维护和扩展。
    
3. **怎么做:** 最佳实践是使用**全局前置守卫 router.beforeEach**。
    
    1. 为路由配置添加 meta 字段，标记需要认证的路由：meta: { requiresAuth: true }。
        
    2. 在 beforeEach 中，检查 to.meta.requiresAuth。
        
    3. 如果需要认证，则检查 Pinia 或 localStorage 中是否存在 token。
        
    4. 若已登录，调用 next() 放行。
        
    5. 若未登录，调用 next({ path: '/login', query: { redirect: to.fullPath } }) 重定向到登录页。
        
    6. 对于不需要认证的路由（白名单），直接 next()。

## 15 pinia

### **Pinia 的 actions vs. getters**

- **优点:** 核心区别概括得非常到位：“actions 更多是封装函数，处理异步和业务逻辑；getters 更像是 computed，用于派生计算属性”。这已经抓住了问题的精髓。
    
- **可改进之处:** 可以补充一下 getters 的一个重要特性——**缓存**。
    
- **修改建议:** 在您的回答后补充一句：“getters 和 computed 一样，其结果会被缓存。只要它依赖的 state 没有发生变化，多次访问 getter 都会立即返回之前缓存的结果，而不会重新计算，这是一种性能优化。而 actions 每次调用都会执行。”

###  **Pinia 数据持久化**

- **优点:** 您直接给出了最佳实践方案——使用 Pinia 插件。思路清晰，核心点 ($subscribe 监听 和 初始化时读取) 都提到了。
    
- **可改进之处:** 可以提及有现成的库可以简化这个过程，体现您的视野广度。
    
- **修改建议:** 在您的回答最后可以补充：“当然，这个逻辑已经有成熟的开源插件了，比如 pinia-plugin-persistedstate，在实际项目中，我们通常会直接使用这类插件，而不是自己手写，这样更高效、更健壮。”