#双指针 

## 简述

这类题目一般具有比较明确的限制/条件，典型题目为：两数之和；接雨水；

[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
这里直接用暴力方法取算直接会超时。可以适当使用双指针来优化，将时间复杂度从`O(n^2)`降为`O(n)`

[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
这题就比较复杂了。可以我们将桶当成宽度为1，的木桶问题，由左右板子的最短长度来决定装水量。还有一个注意点：这个装水量不仅仅和当前的装水量相关，还和之前的板子相关；所以需要使用前缀和、后缀和来计算。

```js
const pre_max = new Array(n).fill(0);
const suf_max = new Array(n).fill(0);
pre_max[0] = height[0];
pre_max[n-1] = height[n-1];
...Math.max...
```

空间优化：
前缀数组可以使用一个最大值变量替代，因为当前最大值不会变小，所以不需要考虑覆盖问题


## 题单

1. [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)
现在再看就比较简单了。二重循环+判断；因为是递增有序数组，对于front + end 和 target进行比较，就可以很轻松得出左右指针的移动顺序。

2. [15. 三数之和](https://leetcode.cn/problems/3sum/)
先固定一个值，之后再使用两数之和的操作；注意去重操作
```js
//固定i时需要处理整个数组都相同的情况
for(let i = 0 ; i < n-1 ; i++){
	const x = nums[i];
	for( i> 0 && num[i-1] === x) continue;
	......
	//固定之后，对剩下的两个指针，也需要去重
	leff++;
	while( left < right && num[left] === num[left -1 ])left++;
	right--;
	while( left < right && num[right] === nums[right+1])right--;
}
//固定
```

3.  [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)
三数之和+记录：需要暂存当前的最小值。

4. [2824. 统计和小于目标的下标对数目](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/)
这里有一个小技巧，方案数+= right - left，对于nums[i] + num[j] < target，区间[i,j]之间的所有结果都满足要求的。
5. [18. 四数之和](https://leetcode.cn/problems/4sum/)
和三数之和类似，需要先固定两个参数，之后再类似两数之和来操作；这里还需要注意去重。
6. [3.无重复的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
熟练掌握map和双指针，当发现当前字符>1时，就移动left直到找到上一个同样的字符
7. [4.四数之和](https://leetcode.cn/problems/4sum/description/)
